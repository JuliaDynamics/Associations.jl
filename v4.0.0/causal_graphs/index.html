<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Network/graph inference · Associations.jl</title><meta name="title" content="Network/graph inference · Associations.jl"/><meta property="og:title" content="Network/graph inference · Associations.jl"/><meta property="twitter:title" content="Network/graph inference · Associations.jl"/><meta name="description" content="Documentation for Associations.jl."/><meta property="og:description" content="Documentation for Associations.jl."/><meta property="twitter:description" content="Documentation for Associations.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Associations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Associations.jl</a></li><li><span class="tocitem">Core API reference</span><ul><li><a class="tocitem" href="../associations/">Association measures</a></li><li><a class="tocitem" href="../independence/">Independence</a></li><li class="is-active"><a class="tocitem" href>Network/graph inference</a><ul class="internal"><li><a class="tocitem" href="#Causal-graph-API"><span>Causal graph API</span></a></li><li><a class="tocitem" href="#docs_OCE"><span>Optimal causation entropy</span></a></li><li><a class="tocitem" href="#[PC](@ref)"><span>PC</span></a></li></ul></li></ul></li><li><span class="tocitem">Extended API reference</span><ul><li><a class="tocitem" href="../api/discretization_counts_probs_api/">Discretization API</a></li><li><a class="tocitem" href="../api/counts_and_probabilities_api/">Multivariate counts and probabilities API</a></li><li><a class="tocitem" href="../api/information_single_variable_api/">Single-variable information API</a></li><li><a class="tocitem" href="../api/information_multivariate_api/">Multivariate information API</a></li><li><a class="tocitem" href="../api/cross_map_api/">Cross-map API</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/examples_associations/">Associations</a></li><li><a class="tocitem" href="../examples/examples_independence/">Independence testing</a></li><li><a class="tocitem" href="../examples/examples_infer_graphs/">Causal graph inference</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Core API reference</a></li><li class="is-active"><a href>Network/graph inference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Network/graph inference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Associations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Associations.jl/blob/main/docs/src/causal_graphs.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="causal_graphs"><a class="docs-heading-anchor" href="#causal_graphs">Inferring causal graphs</a><a id="causal_graphs-1"></a><a class="docs-heading-anchor-permalink" href="#causal_graphs" title="Permalink"></a></h1><p>Directed causal graphical models, estimated on observed data, is an incredibly useful framework for causal inference. There exists a plethora of methods for estimating such models.</p><p>Useful reading:</p><ul><li><strong>Pearl, J. Glymour, M., &amp; Jewell, N. P. (2016). Causal inference in statistics:   A primer. John Wiley &amp; Sons</strong>. An excellent introductory book, suitable for anyone   interested, from a beginners to experts.</li><li><strong>Glymour, C., Zhang, K., &amp; Spirtes, P. (2019). Review of causal discovery methods   based on graphical models. Frontiers in genetics, 10, 524</strong>. The authoritative   overview of causal discovery from graphical models. Many more methods have also emerged   since this paper.</li></ul><h2 id="Causal-graph-API"><a class="docs-heading-anchor" href="#Causal-graph-API">Causal graph API</a><a id="Causal-graph-API-1"></a><a class="docs-heading-anchor-permalink" href="#Causal-graph-API" title="Permalink"></a></h2><p>The API for inferring causal graphs is defined by:</p><ul><li><a href="#Associations.infer_graph"><code>infer_graph</code></a></li><li><a href="#Associations.GraphAlgorithm"><code>GraphAlgorithm</code></a>, and its subtypes</li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Associations.infer_graph" href="#Associations.infer_graph"><code>Associations.infer_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">infer_graph(algorithm::GraphAlgorithm, x) → g</code></pre><p>Infer graph from input data <code>x</code> using the given <code>algorithm</code>.</p><p>Returns <code>g</code>, whose type depends on <code>algorithm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Associations.jl/blob/e394f374faa6b76ffe9b8416eadce4a9efa8b734/src/causal_graphs/api.jl#L16-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Associations.GraphAlgorithm" href="#Associations.GraphAlgorithm"><code>Associations.GraphAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GraphAlgorithm</code></pre><p>The supertype of all causal graph inference algorithms.</p><p><strong>Concrete implementations</strong></p><ul><li><a href="#Associations.OCE"><code>OCE</code></a>. The optimal causation entropy algorithm for time series graphs.</li><li><a href="#Associations.PC"><code>PC</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Associations.jl/blob/e394f374faa6b76ffe9b8416eadce4a9efa8b734/src/causal_graphs/api.jl#L4-L13">source</a></section></article><h2 id="docs_OCE"><a class="docs-heading-anchor" href="#docs_OCE">Optimal causation entropy</a><a id="docs_OCE-1"></a><a class="docs-heading-anchor-permalink" href="#docs_OCE" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Associations.OCE" href="#Associations.OCE"><code>Associations.OCE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OCE &lt;: GraphAlgorithm
OCE(; utest::IndependenceTest = SurrogateAssociationTest(MIShannon(), KSG2(k = 3, w = 3)),
      ctest::C = LocalPermutationTest(CMIShannon(), MesnerShalizi(k = 3, w = 3)),
      τmax::T = 1, α = 0.05)</code></pre><p>The optimal causation entropy (OCE) algorithm for causal discovery <a href="../references/#Sun2015">Sun <em>et al.</em> (2015)</a>.</p><p><strong>Description</strong></p><p>The OCE algorithm has three steps to determine the parents of a variable <code>xᵢ</code>.</p><ol><li>Perform pairwise independence tests using <code>utest</code> and select the variable <code>xⱼ(-τ)</code>  that has the highest significant (i.e. with associated p-value below <code>α</code>)  association with <code>xᵢ(0)</code>. Assign it to the set of selected parents <code>P</code>.</li><li>Perform conditional independence tests using <code>ctest</code>, finding the parent  <code>Pₖ</code> that has the highest association with <code>xᵢ</code> given the already selected parents,  and add it to <code>P</code>.  Repeat until no more variables with significant association are found.</li><li>Backwards elimination of parents <code>Pₖ</code> of <code>xᵢ(0)</code> for which <code>xᵢ(0) ⫫ Pₖ | P - {Pₖ}</code>,  where <code>P</code> is the set of parent nodes found in the previous steps.</li></ol><p><code>τmax</code> indicates the maximum lag <code>τ</code> between the target variable <code>xᵢ(0)</code> and its potential parents <code>xⱼ(-τ)</code>. Sun et al. 2015&#39;s method is based on <code>τmax = 1</code>.</p><p><strong>Returns</strong></p><p>When used with <a href="#Associations.infer_graph"><code>infer_graph</code></a>, it returns a vector <code>p</code>, where <code>p[i]</code> are the parents for each input variable. This result can be converted to a <code>SimpleDiGraph</code> from Graphs.jl (see <a href="../examples/examples_infer_graphs/#oce_example">example</a>).</p><p><strong>Usage</strong></p><p><code>OCE</code> is used with <a href="#Associations.infer_graph"><code>infer_graph</code></a> to infer the parents of the input data. Input data must either be a <code>Vector{Vector{&lt;:Real}}</code>, or a <code>StateSpaceSet</code>.</p><p><strong>Examples</strong></p><ul><li><a href="../examples/examples_infer_graphs/#oce_example">Inferring time series graph from a chain of logistic maps</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Associations.jl/blob/e394f374faa6b76ffe9b8416eadce4a9efa8b734/src/causal_graphs/oce/OCE.jl#L7-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Associations.OCESelectedParents" href="#Associations.OCESelectedParents"><code>Associations.OCESelectedParents</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OCESelectedParents</code></pre><p>A simple struct for storing the parents of a single variable <code>xᵢ</code> inferred by the <a href="#Associations.OCE"><code>OCE</code></a> algorithm. When using <a href="#Associations.OCE"><code>OCE</code></a> with <a href="#Associations.infer_graph"><code>infer_graph</code></a>, a <code>Vector{OCESelectedParents}</code> is returned - one per variable in the input data.</p><p><strong>Assumptions and notation</strong></p><p>Assumes the input <code>x</code> is a <code>Vector{Vector{&lt;:Real}}</code> or a <code>StateSpaceSet</code> (for which each column is treated as a variable). It contains the following fields, where we use the notation <code>xₖ(τ)</code> to indicate the <code>k</code>-th variable lagged by time-lag <code>τ</code>. For example, <code>x₂(-3)</code> is the variable <code>x[2]</code> lagged by 3 time steps.</p><p><strong>Fields</strong></p><ul><li><code>i</code>: The index of the target variable (i.e. <code>xᵢ(0)</code> is the target).</li><li><code>all_idxs</code>: The possible <em>variable</em> indices of parent variables (i.e. <code>1:M</code>,   where <code>M</code> is the number of input variables).</li><li><code>parents_js</code>: The <em>variable</em> indices of the selected parent variables –- one per selected   parent.</li><li><code>parents_τs</code>: The <em>lags</em> for the selected parent variables –- one per selected parent.</li><li><code>parents</code>: A vector containing the raw, time-lagged data for each selected parent   variables. Let <code>τ = parents_τs[k]</code> and <code>j = parents_js[k]</code>. Then <code>parents[k]</code> is   the raw data for the variable <code>xⱼ(-τ)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Associations.jl/blob/e394f374faa6b76ffe9b8416eadce4a9efa8b734/src/causal_graphs/oce/OCE.jl#L53-L78">source</a></section></article><h2 id="[PC](@ref)"><a class="docs-heading-anchor" href="#[PC](@ref)"><a href="#Associations.PC">PC</a></a><a id="[PC](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[PC](@ref)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Associations.PC" href="#Associations.PC"><code>Associations.PC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PC &lt;: GraphAlgorithm
PC(pairwise_test, conditional_test;
    α = 0.05, max_depth = Inf, maxiters_orient = Inf)</code></pre><p>The PC algorithm (<a href="../references/#Spirtes2000">Spirtes <em>et al.</em>, 2000</a>), which is named named after the <em>first names</em> of the authors, <strong>P</strong>eter Spirtes and <strong>C</strong>lark Glymour, which is implemented as described in <a href="../references/#Kalisch2008">Kalisch and Bühlmann (2008)</a>.</p><p><strong>Arguments</strong></p><ul><li><strong><code>pairwise_test</code></strong>: An <a href="../independence/#Associations.IndependenceTest"><code>IndependenceTest</code></a> that uses a pairwise,   nondirectional <a href="../associations/#Associations.AssociationMeasure"><code>AssociationMeasure</code></a> measure (e.g. a parametric   <a href="../independence/#Associations.CorrTest"><code>CorrTest</code></a>, or <a href="../independence/#Associations.SurrogateAssociationTest"><code>SurrogateAssociationTest</code></a> with the <a href="../associations/#Associations.MIShannon"><code>MIShannon</code></a> measure).</li><li><strong><code>conditional_test</code></strong>: An <a href="../independence/#Associations.IndependenceTest"><code>IndependenceTest</code></a> that uses a conditional,   nondirectional <a href="../associations/#Associations.AssociationMeasure"><code>AssociationMeasure</code></a> (e.g. <a href="../independence/#Associations.CorrTest"><code>CorrTest</code></a>,   or <a href="../independence/#Associations.SurrogateAssociationTest"><code>SurrogateAssociationTest</code></a> with the <a href="../associations/#Associations.CMIShannon"><code>CMIShannon</code></a> measure).</li></ul><p><strong>Keyword arguments</strong></p><ul><li><strong><code>α::Real</code></strong>. The significance level of the test.</li><li><strong><code>max_depth</code></strong>. The maximum level of conditional indendence tests to be   performed. By default, there is no limit (i.e. <code>max_depth = Inf</code>), meaning that   maximum depth is <code>N - 2</code>, where <code>N</code> is the number of input variables.</li><li><strong><code>maxiters_orient::Real</code></strong>. The maximum number of times to apply the orientation   rules. By default, there is not limit (i.e. <code>maxiters_orient = Inf</code>).</li></ul><div class="admonition is-info"><header class="admonition-header">Directional measures will not give meaningful answers</header><div class="admonition-body"><p>During the skeleton search phase, if a significance association between two nodes are is found, then a bidirectional edge is drawn between them. The generic implementation of <code>PC</code> therefore doesn&#39;t currently handle directional measures such as <a href="../associations/#Associations.TEShannon"><code>TEShannon</code></a>. The reason is that if a  directional relationship <code>X → Y</code> exists between two nodes <code>X</code> and <code>Y</code>, then the algorithm would first draw a bidirectional arrow between <code>X</code> and <code>Y</code> when analysing the direction <code>X → Y</code>, and then removing it again when analysing in the direction <code>Y → X</code> (a similar situation would also occur for the conditional stage). This will be fixed in a future release. For now, use nondirectional measures, e.g. <a href="../associations/#Associations.MIShannon"><code>MIShannon</code></a> and <a href="../associations/#Associations.CMIShannon"><code>CMIShannon</code></a>!</p></div></div><p><strong>Description</strong></p><p>When used with <a href="#Associations.infer_graph"><code>infer_graph</code></a> on some input data <code>x</code>, the <code>PC</code> algorithm performs the following steps:</p><ol><li>Initialize an empty fully connected graph <code>g</code> with <code>N</code> nodes, where <code>N</code> is the number  of variables and <code>x[i]</code> is the data for the <code>i</code>-th node.</li><li>Reduce the fully connected <code>g</code> to a skeleton graph by performing pairwise  <a href="../independence/#Associations.independence"><code>independence</code></a> tests between all vertices using <code>pairwise_test</code>. Remove  any edges where adjacent vertices are found to be independent according to the test  (i.e. the null hypothesis of independence cannot be rejected at significance level  <code>1 - α</code>).</li><li>Thin the skeleton <code>g</code> by conditional <a href="../independence/#Associations.independence"><code>independence</code></a> testing. If  <code>x[i] ⫫ x[j] | x[Z]</code> for some set of variables <code>Z</code> (not including <code>i</code> and <code>j</code>)  according to <code>conditional_test</code> (i.e. the null hypothesis of conditional independence  cannot be rejected at significance level <code>1 - α</code>), then the edge between <code>i</code> and <code>j</code> is  removed, and we record the separating set S(i, j) = Z. Independence tests are first  performed for conditioning sets of size 1, and repeated for conditioning sets of  increasing size, which in most cases limits the number of tests needed.  The separating  sets <code>S(i, j)</code>, which records which variables were in the conditioning set that  rendered variables <code>i</code> and <code>j</code> independent, are recorded.  If <code>max_depth</code> is an integer, then this procedure is performed on conditioning  sets of sizes <code>1:max_depth</code>, and if <code>max_depth == nothing</code>, then all possible  conditioning set sizes are potentially used.</li><li>Create a directed graph <code>dg</code> from <code>g</code> by replacing every  undirected edge <code>X - Y</code> in <code>g</code> by the bidirectional edge <code>X ↔ Y</code> (i.e.  construct two directional edges <code>X → Y</code> and <code>Y → X</code>). Orientiation rules 0-3  are then repeatedly applied to <code>dg</code> until no more edges can be oriented:<ul><li>Rule 0 (orients v-structures): <code>X ↔ Y ↔ Z</code> becomes <code>X → Y ← Z</code> if <code>Y</code> is not in the   separating set <code>S(X, Z)</code>.</li><li>Rule 1 (prevents new v-structures): <code>X → Y ↔ Z</code> becomes <code>X → Y → Z</code> if <code>X</code> and <code>Z</code>   are not adjacent.</li><li>Rule 2 (avoids cycles): <code>X → Y → Z ↔ X</code> becomes <code>X → Y → Z ← X</code>.</li><li>Rule 3: To avoid creating cycles or new v-structures, whenever <code>X - Y → Z</code>,   <code>X - W → Z</code>, and <code>X - Z</code> but there is no edge between <code>Y</code> and <code>W</code>, turn the   undirected <code>X - Z</code> edge into the directed edge <code>X → Z</code>.</li></ul></li></ol><p>The resulting directed graph (a <code>SimpleDiGraph</code> from <a href="https://github.com/JuliaGraphs/Graphs.jl">Graphs.jl</a>) is then returned.</p><p><strong>Examples</strong></p><ul><li><a href="../examples/examples_infer_graphs/#pc_examples_corr">PC algorithm with parametric independence tests</a></li><li><a href="../examples/examples_infer_graphs/#pc_examples_nonparametric">PC algorithm with nonparametric independence tests</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Associations.jl/blob/e394f374faa6b76ffe9b8416eadce4a9efa8b734/src/causal_graphs/pc/PC.jl#L5-L88">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../independence/">« Independence</a><a class="docs-footer-nextpage" href="../api/discretization_counts_probs_api/">Discretization API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 30 July 2024 20:56">Tuesday 30 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
