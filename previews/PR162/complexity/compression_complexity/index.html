<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Compression complexity · CausalityTools.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="CausalityTools.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="CausalityTools.jl logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><a class="tocitem" href="../../measures/">Association measures</a></li><li><a class="tocitem" href="../../independence/">Independence testing</a></li><li><a class="tocitem" href="../../causal_graphs/">Causal graphs</a></li><li><a class="tocitem" href="../../api/">APIs and estimators</a></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../coupled_systems/">Predefined systems</a></li><li><a class="tocitem" href="../../experimental/">Experimental</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Compression complexity</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Compression complexity</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/CausalityTools.jl/blob/master/docs/src/complexity/compression_complexity.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="compression_complexity"><a class="docs-heading-anchor" href="#compression_complexity">Compression complexity</a><a id="compression_complexity-1"></a><a class="docs-heading-anchor-permalink" href="#compression_complexity" title="Permalink"></a></h1><h2 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>compression_complexity</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CausalityTools.EffortToCompress" href="#CausalityTools.EffortToCompress"><code>CausalityTools.EffortToCompress</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EffortToCompress(; normalize = false)</code></pre><p>The effort-to-compress (ETC; Nagaraj et al., 2013)<sup class="footnote-reference"><a id="citeref-Nagaraj2013" href="#footnote-Nagaraj2013">[Nagaraj2013]</a></sup> algorithm quantifies  the compression complexity of a time series using non-sequential recursive pair  substitution (NSRPS).</p><p>Used with <a href="complexity/@ref"><code>complexity</code></a> to compute ETC and with <a href="complexity/@ref"><code>complexity_normalized</code></a> to compute normalized ETC.  Input time series must be integer-valued. Real-valued or categorical time series  must be symbolized (i.e. represented by integers) before computing the ETC. The number  of symbols should be relatively low, i.e. <code>n_symbols &lt;&lt; length(x)</code>, where <code>x</code> is the input time series. If applied to two time series (e.g.  <code>complexity(EffortToCompress(), x1, x2)</code>), then (bivariate) joint ETC (Kathpalia  and Nagaraj, 2019)<sup class="footnote-reference"><a id="citeref-Kathpalia2019" href="#footnote-Kathpalia2019">[Kathpalia2019]</a></sup> is computed.</p><p><strong>Normalization</strong></p><p>If <code>normalize == false</code>, then the quantity computed is the the number of compression steps  it takes for the symbol sequence to reach zero entropy (either a constant sequence,  or a length-1 sequence).</p><p>For a length-<code>N</code> sequence, the maximum number of possible compression steps is <code>N - 1</code>. If <code>normalize == true</code>, then the ETC value is divided by <code>N - 1</code>, yielding a number on <code>[0, 1]</code>, where <code>0</code> indicates minimal compression complexity and <code>1</code> indicates maximal compression complexity.</p><p><strong>Description</strong></p><p>The ETC algorithm parses a symbol sequence from left to right and finds the symbol with the highest frequency of occurrence. <em>Note: In the case of multiple symbols attaining the  maximum frequency, our implementation does not guarantee that the replaced symbol is  the symbol which first occurs in the sequence. This behaviour differs from the examples in  Nagaraj (2013) and Kathpalia (2019), where they seem to always replace the first-occurring symbol. This does not affect the number of compression steps.</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CausalityTools.jl/blob/ce52b570ccf58554d59516b42b5e705da041a0a7/src/methods/compression/compression_complexity/effort_to_compress/effort_to_compress.jl#L3-L44">source</a></section></article><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>Below is a reproduction of figure 3 in Nagaraj et al. (2013)<sup class="footnote-reference"><a id="citeref-Nagaraj2013" href="#footnote-Nagaraj2013">[Nagaraj2013]</a></sup>, which compares the (approximate) Lyapunov exponent and compression complexity (ETC) of 200-pt long logistic map time series with varying bifurcation parameters.</p><p>For ETC, the time series is symbolized to a binary time series before analysis. Lyapunov exponents are estimated directly on the (non-symbolized) time series.</p><pre><code class="language- hljs">using CausalityTools, Plots, StatsBase, Measures

# Approximation to the Lyapunov exponent for a time series x, from Nagaraj (2013)
function lyapunov(x, a)
    L = length(x)
    lyp = 0.0
    for i in 2:length(x)
        lyp += log(2, abs(a - 2*a*x[i]))
    end
    
    return lyp / L
end


coeffs = 3.5:0.0001:4.0
ls = zeros(length(coeffs))
etcs = zeros(length(coeffs))
for (i, a) in enumerate(coeffs)
    sys = logistic2_unidir(r₁ = a, c_xy = 0.0, σ = 0.0)
    # Generate time series and compute approximate Lyapunov exponents
    x = trajectory(sys, 200, Ttr = 10000)[:, 1]
    ls[i] = lyapunov(x, a)

    # Symbolize and compute effort-to-compress
    y = [xᵢ &gt; 0.5 ? 1 : 0 for xᵢ in x] 
    etcs[i] = compression_complexity(y, EffortToCompress(normalize = false))
end

plot(xlabel = &quot;a&quot;, 
    legend = :topleft, 
    right_margin = 10mm, 
    bottom_margin = 5mm)
plot!(coeffs, ls .- mean(ls), label = &quot;Lyapunov exponent&quot;, c = :red)
plot!(twinx(), coeffs, etcs, label = &quot;ETC&quot;, axis = :right, c = :black)
savefig(&quot;compression_complexity_etc.svg&quot;) # hide</code></pre><p><img src="compression_complexity_etc.svg" alt/></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Nagaraj2013"><a class="tag is-link" href="#citeref-Nagaraj2013">Nagaraj2013</a>Nagaraj, N., Balasubramanian, K., &amp; Dey, S. (2013). A new complexity measure for time series analysis and classification. The European Physical Journal Special Topics, 222(3), 847-860.</li><li class="footnote" id="footnote-Kathpalia2019"><a class="tag is-link" href="#citeref-Kathpalia2019">Kathpalia2019</a>Kathpalia, A., &amp; Nagaraj, N. (2019). Data-based intervention approach for Complexity-Causality measure. PeerJ Computer Science, 5, e196.</li><li class="footnote" id="footnote-Nagaraj2013"><a class="tag is-link" href="#citeref-Nagaraj2013">Nagaraj2013</a>Nagaraj, N., Balasubramanian, K., &amp; Dey, S. (2013). A new complexity measure for time series analysis and classification. The European Physical Journal Special Topics, 222(3), 847-860.</li></ul></section></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 2 May 2023 14:37">Tuesday 2 May 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
