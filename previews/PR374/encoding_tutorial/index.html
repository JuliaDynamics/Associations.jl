<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Encoding elements · CausalityTools.jl</title><meta name="title" content="Encoding elements · CausalityTools.jl"/><meta property="og:title" content="Encoding elements · CausalityTools.jl"/><meta property="twitter:title" content="Encoding elements · CausalityTools.jl"/><meta name="description" content="Documentation for CausalityTools.jl."/><meta property="og:description" content="Documentation for CausalityTools.jl."/><meta property="twitter:description" content="Documentation for CausalityTools.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="CausalityTools.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="CausalityTools.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">CausalityTools.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">CausalityTools.jl</a></li><li><a class="tocitem" href="../associations/">Association measures</a></li><li><a class="tocitem" href="../independence/">Independence</a></li><li><a class="tocitem" href="../causal_graphs/">Network/graph inference</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/examples_associations/">Association measures</a></li><li><a class="tocitem" href="../examples/examples_infer_graphs/">Graph inference</a></li><li><span class="tocitem">Extended examples</span><ul><li><a class="tocitem" href="../extended_examples/cross_mapping/"><code>ConvergentCrossMapping</code></a></li><li><a class="tocitem" href="../extended_examples/pairwise_asymmetric_inference/"><code>PairwiseAsymmetricInference</code></a></li><li><a class="tocitem" href="../extended_examples/mutual_information/"><code>MIShannon</code></a></li></ul></li></ul></li><li><span class="tocitem">Basics and tutorials</span><ul><li class="is-active"><a class="tocitem" href>Encoding elements</a></li><li><a class="tocitem" href="../discretization_tutorial/">Encoding input datasets</a></li><li><a class="tocitem" href="../probabilities_tutorial/">Counts and probabilities</a></li><li><a class="tocitem" href="../info_tutorial/">Information measures</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Basics and tutorials</a></li><li class="is-active"><a href>Encoding elements</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Encoding elements</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/CausalityTools.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/CausalityTools.jl/blob/main/docs/src/encoding_tutorial.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="encoding_api_and_tutorial"><a class="docs-heading-anchor" href="#encoding_api_and_tutorial">Encoding</a><a id="encoding_api_and_tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#encoding_api_and_tutorial" title="Permalink"></a></h1><p>To estimate <a href="../probabilities_tutorial/#Probabilities"><code>Probabilities</code></a>, which are the input to <a href="../associations/#CausalityTools.MultivariateInformationMeasure"><code>MultivariateInformationMeasure</code></a>s,  we encode &quot;encode&quot; input data into an intermediate representation indexed by the positive integers.  This intermediate representation is called an &quot;encoding&quot;.</p><p>We here re-export relevant types and functions <a href="https://github.com/JuliaDynamics/ComplexityMeasures.jl">ComplexityMeasures.jl</a> that perform this type of coarse-graining.</p><p>These encoding schemes are used as input to <a href="../discretization_tutorial/#CausalityTools.CodifyPoints"><code>CodifyPoints</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ComplexityMeasures.Encoding" href="#ComplexityMeasures.Encoding"><code>ComplexityMeasures.Encoding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Encoding</code></pre><p>The supertype for all encoding schemes. Encodings always encode elements of input data into the positive integers. The encoding API is defined by the functions <a href="#ComplexityMeasures.encode"><code>encode</code></a> and <a href="#ComplexityMeasures.decode"><code>decode</code></a>. Some probability estimators utilize encodings internally.</p><p>Current available encodings are:</p><ul><li><a href="#ComplexityMeasures.OrdinalPatternEncoding"><code>OrdinalPatternEncoding</code></a>.</li><li><a href="#ComplexityMeasures.GaussianCDFEncoding"><code>GaussianCDFEncoding</code></a>.</li><li><a href="#ComplexityMeasures.RectangularBinEncoding"><code>RectangularBinEncoding</code></a>.</li><li><a href="#ComplexityMeasures.RelativeMeanEncoding"><code>RelativeMeanEncoding</code></a>.</li><li><a href="#ComplexityMeasures.RelativeFirstDifferenceEncoding"><code>RelativeFirstDifferenceEncoding</code></a>.</li><li><a href="#ComplexityMeasures.UniqueElementsEncoding"><code>UniqueElementsEncoding</code></a>.</li><li><a href="@ref"><code>BubbleSortSwapsEncoding</code></a>.</li><li><a href="@ref"><code>PairDistanceEncoding</code></a>.</li><li><a href="#ComplexityMeasures.CombinationEncoding"><code>CombinationEncoding</code></a>, which can combine any of the above encodings.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/v3.6.5/src/core/encodings.jl#L3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ComplexityMeasures.GaussianCDFEncoding" href="#ComplexityMeasures.GaussianCDFEncoding"><code>ComplexityMeasures.GaussianCDFEncoding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussianCDFEncoding &lt;: Encoding
GaussianCDFEncoding{m}(; μ, σ, c::Int = 3)</code></pre><p>An encoding scheme that <a href="#ComplexityMeasures.encode"><code>encode</code></a>s a scalar or vector <code>χ</code> into one of the integers <code>sᵢ ∈ [1, 2, …, c]</code> based on the normal cumulative distribution function (NCDF), and <a href="#ComplexityMeasures.decode"><code>decode</code></a>s the <code>sᵢ</code> into subintervals of <code>[0, 1]</code> (with some loss of information).</p><p><strong>Initializing a <code>GaussianCDFEncoding</code></strong></p><p>The size of the input to be encoded must be known beforehand. One must therefore set <code>m = length(χ)</code>, where <code>χ</code> is the input (<code>m = 1</code> for scalars, <code>m ≥ 2</code> for vectors). To do so, one must explicitly give <code>m</code> as a type parameter: e.g. <code>encoding = GaussianCDFEncoding{3}(; μ = 0.0, σ = 0.1)</code> to encode 3-element vectors, or <code>encoding = GaussianCDFEncoding{1}(; μ = 0.0, σ = 0.1)</code> to encode scalars.</p><p><strong>Description</strong></p><p><strong>Encoding/decoding scalars</strong></p><p><code>GaussianCDFEncoding</code> first maps an input scalar <span>$χ$</span> to a new real number <span>$y_ \in [0, 1]$</span> by using the normal cumulative distribution function (CDF) with the given mean <code>μ</code> and standard deviation <code>σ</code>, according to the map</p><p class="math-container">\[x \to y : y = \dfrac{1}{ \sigma
    \sqrt{2 \pi}} \int_{-\infty}^{x} e^{(-(x - \mu)^2)/(2 \sigma^2)} dx.\]</p><p>Next, the interval <code>[0, 1]</code> is equidistantly binned and enumerated <span>$1, 2, \ldots, c$</span>,  and <span>$y$</span> is linearly mapped to one of these integers using the linear map  <span>$y \to z : z = \text{floor}(y(c-1)) + 1$</span>.</p><p>Because of the floor operation, some information is lost, so when used with <a href="#ComplexityMeasures.decode"><code>decode</code></a>, each decoded <code>sᵢ</code> is mapped to a <em>subinterval</em> of <code>[0, 1]</code>. This subinterval is returned as a length-<code>1</code> <code>Vector{SVector}</code>.</p><p>Notice that the decoding step does not yield an element of any outcome space of the estimators that use <code>GaussianCDFEncoding</code> internally, such as <a href="../discretization_tutorial/#ComplexityMeasures.Dispersion"><code>Dispersion</code></a>. That is because these estimators additionally delay embed the encoded data.</p><p><strong>Encoding/decoding vectors</strong></p><p>If <code>GaussianCDFEncoding</code> is used with a vector <code>χ</code>, then each element of <code>χ</code> is encoded separately, resulting in a <code>length(χ)</code> sequence of integers which may be treated as a <code>CartesianIndex</code>. The encoded symbol <code>s ∈ [1, 2, …, c]</code> is then just the linear index corresponding to this cartesian index (similar to how <a href="#ComplexityMeasures.CombinationEncoding"><code>CombinationEncoding</code></a> works).</p><p>When <a href="#ComplexityMeasures.decode"><code>decode</code></a>d, the integer symbol <code>s</code> is converted back into its <code>CartesianIndex</code> representation,  which is just a sequence of integers that refer to subdivisions of the <code>[0, 1]</code> interval. The relevant subintervals are then returned as a length-<code>χ</code> <code>Vector{SVector}</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using ComplexityMeasures, Statistics

julia&gt; x = [0.1, 0.4, 0.7, -2.1, 8.0];

julia&gt; μ, σ = mean(x), std(x); encoding = GaussianCDFEncoding(; μ, σ, c = 5)

julia&gt; es = encode.(Ref(encoding), x)
5-element Vector{Int64}:
 2
 2
 3
 1
 5

julia&gt; decode(encoding, 3)
2-element SVector{2, Float64} with indices SOneTo(2):
 0.4
 0.6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/v3.6.5/src/encoding_implementations/gaussian_cdf.jl#L6-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ComplexityMeasures.OrdinalPatternEncoding" href="#ComplexityMeasures.OrdinalPatternEncoding"><code>ComplexityMeasures.OrdinalPatternEncoding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OrdinalPatternEncoding &lt;: Encoding
OrdinalPatternEncoding{m}(lt = ComplexityMeasures.isless_rand)</code></pre><p>An encoding scheme that <a href="#ComplexityMeasures.encode"><code>encode</code></a>s length-<code>m</code> vectors into their permutation/ordinal patterns and then into the integers based on the Lehmer code. It is used by <a href="../discretization_tutorial/#ComplexityMeasures.OrdinalPatterns"><code>OrdinalPatterns</code></a> and similar estimators, see that for a description of the outcome space.</p><p>The ordinal/permutation pattern of a vector <code>χ</code> is simply <code>sortperm(χ)</code>, which gives the indices that would sort <code>χ</code> in ascending order.</p><p><strong>Description</strong></p><p>The Lehmer code, as implemented here, is a bijection between the set of <code>factorial(m)</code> possible permutations for a length-<code>m</code> sequence, and the integers <code>1, 2, …, factorial(m)</code>. The encoding step uses algorithm 1 in <a href="../references/#Berger2019">Berger <em>et al.</em> (2019)</a>, which is highly optimized. The decoding step is much slower due to missing optimizations (pull requests welcomed!).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using ComplexityMeasures

julia&gt; χ = [4.0, 1.0, 9.0];

julia&gt; c = OrdinalPatternEncoding(3);

julia&gt; i = encode(c, χ)
3

julia&gt; decode(c, i)
3-element SVector{3, Int64} with indices SOneTo(3):
 2
 1
 3</code></pre><p>If you want to encode something that is already a permutation pattern, then you can use the non-exported <code>permutation_to_integer</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/v3.6.5/src/encoding_implementations/ordinal_pattern.jl#L6-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ComplexityMeasures.RelativeMeanEncoding" href="#ComplexityMeasures.RelativeMeanEncoding"><code>ComplexityMeasures.RelativeMeanEncoding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RelativeMeanEncoding &lt;: Encoding
RelativeMeanEncoding(minval::Real, maxval::Real; n = 2)</code></pre><p><code>RelativeMeanEncoding</code> encodes a vector based on the relative position the mean of the vector has with respect to a predefined minimum and maximum value (<code>minval</code> and <code>maxval</code>, respectively).</p><p><strong>Description</strong></p><p>This encoding is inspired by <a href="../references/#Azami2016">Azami and Escudero (2016)</a>&#39;s algorithm for amplitude-aware permutation entropy. They use a linear combination of amplitude information and first differences information of state vectors to correct probabilities. Here, however, we explicitly encode the amplitude-part of the correction as an a integer symbol <code>Λ ∈ [1, 2, …, n]</code>. The first-difference part of the encoding is available as the <a href="#ComplexityMeasures.RelativeFirstDifferenceEncoding"><code>RelativeFirstDifferenceEncoding</code></a> encoding.</p><p><strong>Encoding/decoding</strong></p><p>When used with <a href="#ComplexityMeasures.encode"><code>encode</code></a>, an <span>$m$</span>-element state vector <span>$\bf{x} = (x_1, x_2, \ldots, x_m)$</span> is encoded as <span>$Λ = \dfrac{1}{N}\sum_{i=1}^m abs(x_i)$</span>. The value of <span>$Λ$</span> is then normalized to lie on the interval <code>[0, 1]</code>, assuming that the minimum/maximum value any single element <span>$x_i$</span> can take is <code>minval</code>/<code>maxval</code>, respectively. Finally, the interval <code>[0, 1]</code> is discretized into <code>n</code> discrete bins, enumerated by positive integers <code>1, 2, …, n</code>, and the number of the bin that the normalized <span>$Λ$</span> falls into is returned.</p><p>When used with <a href="#ComplexityMeasures.decode"><code>decode</code></a>, the left-edge of the bin that the normalized <span>$Λ$</span> fell into is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/v3.6.5/src/encoding_implementations/relative_mean_encoding.jl#L3-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ComplexityMeasures.RelativeFirstDifferenceEncoding" href="#ComplexityMeasures.RelativeFirstDifferenceEncoding"><code>ComplexityMeasures.RelativeFirstDifferenceEncoding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RelativeFirstDifferenceEncoding &lt;: Encoding
RelativeFirstDifferenceEncoding(minval::Real, maxval::Real; n = 2)</code></pre><p><code>RelativeFirstDifferenceEncoding</code> encodes a vector based on the relative position the average of the <em>first differences</em> of the vectors has with respect to a predefined minimum and maximum value (<code>minval</code> and <code>maxval</code>, respectively).</p><p><strong>Description</strong></p><p>This encoding is inspired by <a href="../references/#Azami2016">Azami and Escudero (2016)</a>&#39;s algorithm for amplitude-aware permutation entropy. They use a linear combination of amplitude information and first differences information of state vectors to correct probabilities. Here, however, we explicitly encode the first differences part of the correction as an a integer symbol <code>Λ ∈ [1, 2, …, n]</code>. The amplitude part of the encoding is available as the <a href="#ComplexityMeasures.RelativeMeanEncoding"><code>RelativeMeanEncoding</code></a> encoding.</p><p><strong>Encoding/decoding</strong></p><p>When used with <a href="#ComplexityMeasures.encode"><code>encode</code></a>, an <span>$m$</span>-element state vector <span>$\bf{x} = (x_1, x_2, \ldots, x_m)$</span> is encoded as <span>$Λ = \dfrac{1}{m - 1}\sum_{k=2}^m |x_{k} - x_{k-1}|$</span>. The value of <span>$Λ$</span> is then normalized to lie on the interval <code>[0, 1]</code>, assuming that the minimum/maximum value any single <span>$abs(x_k - x_{k-1})$</span> can take is <code>minval</code>/<code>maxval</code>, respectively. Finally, the interval <code>[0, 1]</code> is discretized into <code>n</code> discrete bins, enumerated by positive integers <code>1, 2, …, n</code>, and the number of the bin that the normalized <span>$Λ$</span> falls into is returned. The smaller the mean first difference of the state vector is, the smaller the bin number is. The higher the mean first difference of the state vectors is, the higher the bin number is.</p><p>When used with <a href="#ComplexityMeasures.decode"><code>decode</code></a>, the left-edge of the bin that the normalized <span>$Λ$</span> fell into is returned.</p><p><strong>Performance tips</strong></p><p>If you are encoding multiple input vectors, it is more efficient to construct a <a href="#ComplexityMeasures.RelativeFirstDifferenceEncoding"><code>RelativeFirstDifferenceEncoding</code></a> instance and re-use it:</p><pre><code class="language-julia hljs">minval, maxval = 0, 1
encoding = RelativeFirstDifferenceEncoding(minval, maxval; n = 4)
pts = [rand(3) for i = 1:1000]
[encode(encoding, x) for x in pts]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/v3.6.5/src/encoding_implementations/relative_first_difference_encoding.jl#L3-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ComplexityMeasures.UniqueElementsEncoding" href="#ComplexityMeasures.UniqueElementsEncoding"><code>ComplexityMeasures.UniqueElementsEncoding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UniqueElementsEncoding &lt;: Encoding
UniqueElementsEncoding(x)</code></pre><p><code>UniqueElementsEncoding</code> is a generic encoding that encodes each <code>xᵢ ∈ unique(x)</code> to one of the positive integers. The <code>xᵢ</code> are encoded according to the order of their first appearance in the input data.</p><p>The constructor requires the input data <code>x</code>, since the number of possible symbols is <code>length(unique(x))</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using ComplexityMeasures
x = [&#39;a&#39;, 2, 5, 2, 5, &#39;a&#39;]
e = UniqueElementsEncoding(x)
encode.(Ref(e), x) == [1, 2, 3, 2, 3, 1] # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/v3.6.5/src/encoding_implementations/unique_elements_encoding.jl#L5-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ComplexityMeasures.RectangularBinEncoding" href="#ComplexityMeasures.RectangularBinEncoding"><code>ComplexityMeasures.RectangularBinEncoding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RectangularBinEncoding &lt;: Encoding
RectangularBinEncoding(binning::RectangularBinning, x)
RectangularBinEncoding(binning::FixedRectangularBinning)</code></pre><p>An encoding scheme that <a href="#ComplexityMeasures.encode"><code>encode</code></a>s points <code>χ ∈ x</code> into their histogram bins.</p><p>The first call signature simply initializes a <a href="../discretization_tutorial/#ComplexityMeasures.FixedRectangularBinning"><code>FixedRectangularBinning</code></a> and then calls the second call signature.</p><p>See <a href="../discretization_tutorial/#ComplexityMeasures.FixedRectangularBinning"><code>FixedRectangularBinning</code></a> for info on mapping points to bins.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/v3.6.5/src/encoding_implementations/rectangular_binning.jl#L101-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ComplexityMeasures.CombinationEncoding" href="#ComplexityMeasures.CombinationEncoding"><code>ComplexityMeasures.CombinationEncoding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CombinationEncoding &lt;: Encoding
CombinationEncoding(encodings)</code></pre><p>A <code>CombinationEncoding</code> takes multiple <a href="#ComplexityMeasures.Encoding"><code>Encoding</code></a>s and creates a combined encoding that can be used to encode inputs that are compatible with the given <code>encodings</code>.</p><p><strong>Encoding/decoding</strong></p><p>When used with <a href="#ComplexityMeasures.encode"><code>encode</code></a>, each <a href="#ComplexityMeasures.Encoding"><code>Encoding</code></a> in <code>encodings</code> returns integers in the set <code>1, 2, …, n_e</code>, where <code>n_e</code> is the total number of outcomes for a particular encoding. For <code>k</code> different encodings, we can thus construct the cartesian coordinate <code>(c₁, c₂, …, cₖ)</code> (<code>cᵢ ∈ 1, 2, …, n_i</code>), which can uniquely be identified by an integer. We can thus identify each unique <em>combined</em> encoding with a single integer.</p><p>When used with <a href="#ComplexityMeasures.decode"><code>decode</code></a>, the integer symbol is converted to its corresponding cartesian coordinate, which is used to retrieve the decoded symbols for each of the encodings, and a tuple of the decoded symbols are returned.</p><p>The total number of outcomes is <code>prod(total_outcomes(e) for e in encodings)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using ComplexityMeasures

# We want to encode the vector `x`.
x = [0.9, 0.2, 0.3]

# To do so, we will use a combination of first-difference encoding, amplitude encoding,
# and ordinal pattern encoding.

encodings = (
    RelativeFirstDifferenceEncoding(0, 1; n = 2),
    RelativeMeanEncoding(0, 1; n = 5),
    OrdinalPatternEncoding(3) # x is a three-element vector
    )
c = CombinationEncoding(encodings)

# Encode `x` as integer
ω = encode(c, x)

# Decode symbol (into a vector of decodings, one for each encodings `e ∈ encodings`).
# In this particular case, the first two element will be left-bin edges, and
# the last element will be the decoded ordinal pattern (indices that would sort `x`).
d = decode(c, ω)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/v3.6.5/src/encoding_implementations/combination_encoding.jl#L3-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ComplexityMeasures.encode" href="#ComplexityMeasures.encode"><code>ComplexityMeasures.encode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">encode(c::Encoding, χ) -&gt; i::Int</code></pre><p>Encode an element <code>χ ∈ x</code> of input data <code>x</code> (those given to e.g., <a href="../probabilities_tutorial/#ComplexityMeasures.counts-Tuple{OutcomeSpace}"><code>counts</code></a>) into the <strong>positive integers</strong> using encoding <code>c</code>. The special value of <code>i = -1</code> is used as a return value for inappropriate elements <code>χ</code> that cannot be encoded according to <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/v3.6.5/src/core/encodings.jl#L25-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ComplexityMeasures.decode" href="#ComplexityMeasures.decode"><code>ComplexityMeasures.decode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decode(c::Encoding, i::Integer) -&gt; ω</code></pre><p>Decode an encoded element <code>i</code> into the outcome <code>ω ∈ Ω</code> it corresponds to. <code>Ω</code> is the <a href="@ref"><code>outcome_space</code></a> that uses encoding <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/v3.6.5/src/core/encodings.jl#L35-L40">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../extended_examples/mutual_information/">« <code>MIShannon</code></a><a class="docs-footer-nextpage" href="../discretization_tutorial/">Encoding input datasets »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Wednesday 24 July 2024 01:54">Wednesday 24 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
