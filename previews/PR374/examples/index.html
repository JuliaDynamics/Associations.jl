<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Cross mapping ¬∑ CausalityTools.jl</title><meta name="title" content="Cross mapping ¬∑ CausalityTools.jl"/><meta property="og:title" content="Cross mapping ¬∑ CausalityTools.jl"/><meta property="twitter:title" content="Cross mapping ¬∑ CausalityTools.jl"/><meta name="description" content="Documentation for CausalityTools.jl."/><meta property="og:description" content="Documentation for CausalityTools.jl."/><meta property="twitter:description" content="Documentation for CausalityTools.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="CausalityTools.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="CausalityTools.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">CausalityTools.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">CausalityTools.jl</a></li><li><a class="tocitem" href="../associations/">Association measures</a></li><li><a class="tocitem" href="../independence/">Independence</a></li><li><a class="tocitem" href="../causal_graphs/">Network/graph inference</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples_associations/">Association measures</a></li><li><a class="tocitem" href="examples_infer_graphs/">Graph inference</a></li><li><span class="tocitem">Extended examples</span><ul><li><a class="tocitem" href="../extended_examples/cross_mapping/"><code>ConvergentCrossMapping</code></a></li><li><a class="tocitem" href="../extended_examples/pairwise_asymmetric_inference/"><code>PairwiseAsymmetricInference</code></a></li><li><a class="tocitem" href="../extended_examples/mutual_information/"><code>MIShannon</code></a></li></ul></li></ul></li><li><span class="tocitem">Basics and tutorials</span><ul><li><a class="tocitem" href="../encoding_tutorial/">Encoding elements</a></li><li><a class="tocitem" href="../discretization_tutorial/">Encoding input datasets</a></li><li><a class="tocitem" href="../probabilities_tutorial/">Counts and probabilities</a></li><li><a class="tocitem" href="../info_tutorial/">Information measures</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Cross mapping</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Cross mapping</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/CausalityTools.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/CausalityTools.jl/blob/main/docs/src/examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="examples_crossmappings"><a class="docs-heading-anchor" href="#examples_crossmappings">Cross mapping</a><a id="examples_crossmappings-1"></a><a class="docs-heading-anchor-permalink" href="#examples_crossmappings" title="Permalink"></a></h1><h2 id="[ConvergentCrossMapping](@ref)-directly"><a class="docs-heading-anchor" href="#[ConvergentCrossMapping](@ref)-directly"><a href="../associations/#CausalityTools.ConvergentCrossMapping"><code>ConvergentCrossMapping</code></a> directly</a><a id="[ConvergentCrossMapping](@ref)-directly-1"></a><a class="docs-heading-anchor-permalink" href="#[ConvergentCrossMapping](@ref)-directly" title="Permalink"></a></h2><pre><code class="language-julia hljs">using CausalityTools
x, y = rand(200), rand(100)
crossmap(CCM(), x, y)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.14908776506439866</code></pre><h2 id="[ConvergentCrossMapping](@ref)-with-[RandomVectors](@ref)"><a class="docs-heading-anchor" href="#[ConvergentCrossMapping](@ref)-with-[RandomVectors](@ref)"><a href="../associations/#CausalityTools.ConvergentCrossMapping"><code>ConvergentCrossMapping</code></a> with <a href="../associations/#CausalityTools.RandomVectors"><code>RandomVectors</code></a></a><a id="[ConvergentCrossMapping](@ref)-with-[RandomVectors](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[ConvergentCrossMapping](@ref)-with-[RandomVectors](@ref)" title="Permalink"></a></h2><p>When cross-mapping with the <a href="../associations/#CausalityTools.RandomVectors"><code>RandomVectors</code></a> estimator, a single random subsample of time indices (i.e. not in any particular order) of length <code>l</code> is drawn for each library size <code>l</code>, and cross mapping is performed using the embedding vectors corresponding to those time indices.</p><pre><code class="language-julia hljs">using CausalityTools
using Random; rng = MersenneTwister(1234)
x, y = randn(rng, 200), randn(rng, 200)

# We&#39;ll draw a single sample at each `l ‚àà libsizes`. Sampling with replacement is then
# necessary, because our 200-pt timeseries will result in embeddings with
# less than 200 points.
est = RandomVectors(CCM(); libsizes = 50:25:200, replace = true, rng)
crossmap(est, x, y)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7-element Vector{Float64}:
 0.210886601539049
 0.46820717498545883
 0.6042803324120247
 0.4418085128932377
 0.7513406469941841
 0.6506240901052961
 0.6865204452030625</code></pre><p>To generate a distribution of cross-map estimates for each <code>l ‚àà libsizes</code>, just call crossmap repeatedly, e.g.</p><pre><code class="language-julia hljs">using CausalityTools
using Random; rng = MersenneTwister(1234)
x, y = randn(rng, 200), randn(rng, 200)
est = RandomVectors(CCM(); libsizes = 50:25:200, replace = true, rng)
œÅs = [crossmap(est, x, y) for i = 1:55]
M = hcat(œÅs...)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7√ó55 Matrix{Float64}:
 0.210887  0.33314   0.190171  0.279668  ‚Ä¶  0.12761   0.665407  0.226338
 0.468207  0.417712  0.597662  0.534512     0.456876  0.42008   0.192752
 0.60428   0.539928  0.220202  0.688577     0.395248  0.609936  0.609391
 0.441809  0.48504   0.454435  0.529148     0.582926  0.46596   0.697269
 0.751341  0.609762  0.700592  0.605519     0.808495  0.811922  0.582597
 0.650624  0.692619  0.634448  0.666943  ‚Ä¶  0.672901  0.678747  0.692988
 0.68652   0.731415  0.743269  0.665061     0.673982  0.683377  0.785139</code></pre><p>Now, the <code>k</code>-th row of <code>M</code> contains <code>55</code> estimates of the correspondence measure <code>œÅ</code> at library size <code>libsizes[k]</code>.</p><h3 id="[ConvergentCrossMapping](@ref)-with-[RandomSegments](@ref)"><a class="docs-heading-anchor" href="#[ConvergentCrossMapping](@ref)-with-[RandomSegments](@ref)"><a href="../associations/#CausalityTools.ConvergentCrossMapping"><code>ConvergentCrossMapping</code></a> with <a href="@ref"><code>RandomSegments</code></a></a><a id="[ConvergentCrossMapping](@ref)-with-[RandomSegments](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[ConvergentCrossMapping](@ref)-with-[RandomSegments](@ref)" title="Permalink"></a></h3><p>When cross-mapping with the <a href="@ref"><code>RandomSegments</code></a> estimator, a single random subsample of continguous, ordered time indices of length <code>l</code> is drawn for each library size <code>l</code>, and cross mapping is performed using the embedding vectors corresponding to those time indices.</p><pre><code class="language-julia hljs">using CausalityTools
using Random; rng = MersenneTwister(1234)
x, y = randn(rng, 200), randn(rng, 200)

# We&#39;ll draw a single sample at each `l ‚àà libsizes`. We limit the library size to 100,
# because drawing segments of the data longer than half the available data doesn&#39;t make
# much sense.
est = RandomSegment(CCM(); libsizes = 50:25:100, rng)
crossmap(est, x, y)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
 -0.26340558043659157
 -0.15242595614243196
  0.05922060684761442</code></pre><p>As above, to generate a distribution of cross-map estimates for each <code>l ‚àà libsizes</code>, just call crossmap repeatedly, e.g.</p><pre><code class="language-julia hljs">using CausalityTools
using Random; rng = MersenneTwister(1234)
x, y = randn(rng, 200), randn(rng, 200)
est = RandomSegment(CCM(); libsizes = 50:25:100, rng)
œÅs = [crossmap(est, x, y) for i = 1:80]
M = hcat(œÅs...)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3√ó80 Matrix{Float64}:
 -0.263406   -0.0490479  -0.158317  ‚Ä¶  0.133171  0.0546626   0.0218741
 -0.152426    0.0976493   0.1187       0.075465  0.17305    -0.209556
  0.0592206   0.0776023   0.115505     0.145298  0.0690925   0.0398285</code></pre><p>Now, the <code>k</code>-th row of <code>M</code> contains <code>80</code> estimates of the correspondence measure <code>œÅ</code> at library size <code>libsizes[k]</code>.</p><h3 id="Reproducing-Sugihara-et-al.-(2012)"><a class="docs-heading-anchor" href="#Reproducing-Sugihara-et-al.-(2012)">Reproducing Sugihara et al. (2012)</a><a id="Reproducing-Sugihara-et-al.-(2012)-1"></a><a class="docs-heading-anchor-permalink" href="#Reproducing-Sugihara-et-al.-(2012)" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Run blocks consecutively</header><div class="admonition-body"><p>If copying these examples and running them locally, make sure the relevant packages (given in the first block) are loaded first.</p></div></div><h4 id="Figure-3A"><a class="docs-heading-anchor" href="#Figure-3A">Figure 3A</a><a id="Figure-3A-1"></a><a class="docs-heading-anchor-permalink" href="#Figure-3A" title="Permalink"></a></h4><p>Let&#39;s reproduce figure 3A too, focusing only on <a href="../associations/#CausalityTools.ConvergentCrossMapping"><code>ConvergentCrossMapping</code></a> this time. In this figure, they compute the cross mapping for libraries of increasing size, always starting at time index 1. This approach - which we here call the <a href="../associations/#CausalityTools.ExpandingSegment"><code>ExpandingSegment</code></a> estimator - is one of many ways of estimating the correspondence between observed and predicted value.</p><p>For this example, they use a bidirectional system with asymmetrical coupling strength.</p><pre><code class="language-julia hljs">using CausalityTools
using Statistics
using LabelledArrays
using StaticArrays
using DynamicalSystemsBase
using StateSpaceSets
using CairoMakie, Printf

function eom_logistic_sugi(u, p, t)
    (; rx, ry, Œ≤xy, Œ≤yx) = p
    (; x, y) = u

    dx = x*(rx - rx*x - Œ≤xy*y)
    dy = y*(ry - ry*y - Œ≤yx*x)
    return SVector{2}(dx, dy)
end

# Œ≤xy := effect on x of y
# Œ≤yx := effect on y of x
function logistic_sugi(; u0 = rand(2), rx, ry, Œ≤xy, Œ≤yx)
    p = @LArray [rx, ry, Œ≤xy, Œ≤yx] (:rx, :ry, :Œ≤xy, :Œ≤yx)
    DiscreteDynamicalSystem(eom_logistic_sugi, u0, p)
end

# Used in `reproduce_figure_3A_naive`, and `reproduce_figure_3A_ensemble` below.
function add_to_fig!(fig_pos, libsizes, œÅs_xÃÇy, œÅs_yÃÇx; title = &quot;&quot;, quantiles = false)
    ax = Axis(fig_pos; title, aspect = 1,
        xlabel = &quot;Library size&quot;, ylabel = &quot;Correlation (œÅ)&quot;)
    ylims!(ax, (-1, 1))
    hlines!([0], linestyle = :dash, alpha = 0.5, color = :grey)
    scatterlines!(libsizes, median.(œÅs_xÃÇy), label = &quot;xÃÇ|y&quot;, color = :blue)
    scatterlines!(libsizes, median.(œÅs_yÃÇx), label = &quot;yÃÇ|x&quot;, color = :red)
    if quantiles
        band!(libsizes, quantile.(œÅs_xÃÇy, 0.05), quantile.(œÅs_xÃÇy, 0.95), color = (:blue, 0.5))
        band!(libsizes, quantile.(œÅs_yÃÇx, 0.05), quantile.(œÅs_yÃÇx, 0.95), color = (:red, 0.5))
    end
    axislegend(ax, position = :rb)
end

function reproduce_figure_3A_naive(definition::CrossmapMeasure)
    sys_bidir = logistic_sugi(; u0 = [0.2, 0.4], rx = 3.7, ry = 3.700001, Œ≤xy = 0.02, Œ≤yx = 0.32);
    x, y = columns(first(trajectory(sys_bidir, 3100, Ttr = 10000)));
    libsizes = [20:2:50; 60:10:200; 300:50:500; 600:150:900; 1000:500:2000]
    est = ExpandingSegment(definition; libsizes);
    œÅs_xÃÇy = crossmap(est, x, y)
    œÅs_yÃÇx = crossmap(est, y, x)

    with_theme(theme_minimal(),
        markersize = 5) do
        fig = Figure(resolution = (800, 300))
        add_to_fig!(fig[1, 1], libsizes, œÅs_xÃÇy, œÅs_yÃÇx; title = &quot;`ExpandingSegment`&quot;)
        fig
    end
end

reproduce_figure_3A_naive(ConvergentCrossMapping(d = 3))</code></pre><img src="4eb1ce3f.png" alt="Example block output"/><p>Hm. This looks a bit like the paper, but the curve is not smooth. We can do better!</p><p>It is not clear from the paper exactly <em>what</em> they plot in their Figure 3A, if they plot an average of some kind, or precisely what parameters and initial conditions they use. However, we can get a smoother plot by using a <a href="@ref"><code>Ensemble</code></a>. Combined with a <a href="../associations/#CausalityTools.CrossmapEstimator"><code>CrossmapEstimator</code></a>, it uses Monte Carlo resampling on subsets of the input data to compute an ensemble of <code>œÅ</code>s that we here use to compute the median and 90-th percentile range for each library size.</p><pre><code class="language-julia hljs">function reproduce_figure_3A_ensemble(definition::CrossmapMeasure)
    sys_bidir = logistic_sugi(; u0 = [0.4, 0.2], rx = 3.8, ry = 3.5, Œ≤xy = 0.02, Œ≤yx = 0.1);
    x, y = columns(first(trajectory(sys_bidir, 5000, Ttr = 10000)));
    # Note: our time series are 1000 points long. When embedding, some points are
    # lost, so we must use slightly less points for the segments than
    # there are points in the original time series.
    libsizes = [20:2:50; 60:10:200; 300:50:500; 600:150:900; 1000:500:2000]
    # No point in doing more than one rep, because there data are always the same
    # for `ExpandingSegment.`
    ensemble_ev = Ensemble(ExpandingSegment(definition; libsizes); nreps = 1)
    ensemble_rs = Ensemble(RandomSegment(definition; libsizes); nreps = 30)
    ensemble_rv = Ensemble(RandomVectors(definition; libsizes); nreps = 30)
    œÅs_xÃÇy_es = crossmap(ensemble_ev, x, y)
    œÅs_yÃÇx_es = crossmap(ensemble_ev, y, x)
    œÅs_xÃÇy_rs = crossmap(ensemble_rs, x, y)
    œÅs_yÃÇx_rs = crossmap(ensemble_rs, y, x)
    œÅs_xÃÇy_rv = crossmap(ensemble_rv, x, y)
    œÅs_yÃÇx_rv = crossmap(ensemble_rv, y, x)

    with_theme(theme_minimal(),
        markersize = 5) do
        fig = Figure(resolution = (800, 300))
        add_to_fig!(fig[1, 1], libsizes, œÅs_xÃÇy_es, œÅs_yÃÇx_es; title = &quot;`ExpandingSegment`&quot;, quantiles = false) # quantiles make no sense for `ExpandingSegment`
        add_to_fig!(fig[1, 2], libsizes, œÅs_xÃÇy_rs, œÅs_yÃÇx_rs; title = &quot;`RandomSegment`&quot;, quantiles = true)
        add_to_fig!(fig[1, 3], libsizes, œÅs_xÃÇy_rv, œÅs_yÃÇx_rv; title = &quot;`RandomVector`&quot;, quantiles = true)
        fig
    end
end

reproduce_figure_3A_ensemble(ConvergentCrossMapping(d = 3, œÑ = -1))</code></pre><img src="4edd4569.png" alt="Example block output"/><p>With the <a href="../associations/#CausalityTools.RandomVectors"><code>RandomVectors</code></a> estimator, the mean of our ensemble <code>œÅ</code>s seem to look pretty much identical to Figure 3A in Sugihara et al. The <a href="../associations/#CausalityTools.RandomSegment"><code>RandomSegment</code></a> estimator also performs pretty well, but since subsampled segments are contiguous, there are probably some autocorrelation effects at play.</p><p>We can avoid the autocorrelation issue by tuning the <code>w</code> parameter of the <a href="../associations/#CausalityTools.ConvergentCrossMapping"><code>ConvergentCrossMapping</code></a> measure, which is the  <a href="https://juliadynamics.github.io/DynamicalSystems.jl/dev/embedding/StateSpaceSet/#Theiler-window">Theiler window</a>. Setting the Theiler window to <code>w &gt; 0</code>, we can exclude neighbors of a query point <code>p</code> that are close to <code>p</code> in time, and thus deal with autocorrelation issues that way (the default <code>w = 0</code> excludes only the point itself). Let&#39;s re-do the analysis with <code>w = 5</code>, just for fun.</p><pre><code class="language-julia hljs">reproduce_figure_3A_ensemble(ConvergentCrossMapping(d = 3, œÑ = -1, w = 5))</code></pre><img src="b3af52b9.png" alt="Example block output"/><p>There wasn&#39;t really that much of a difference, since for the logistic map, the autocorrelation function flips sign for every lag increase. However, for examples from other systems, tuning <code>w</code> may be important.</p><h4 id="Figure-3B"><a class="docs-heading-anchor" href="#Figure-3B">Figure 3B</a><a id="Figure-3B-1"></a><a class="docs-heading-anchor-permalink" href="#Figure-3B" title="Permalink"></a></h4><p>What about figure 3B? Here they generate time series of length 400 for a range of values for both coupling parameters, and plot the dominant direction <span>$\Delta = \rho(\hat{x} | y) - \rho(\hat{y} | x)$</span>.</p><p>In the paper, they use a 1000 different parameterizations for the logistic map parameters, but don&#39;t state what is summarized in the plot. For simplicity, we&#39;ll therefore just stick to <code>rx = ry = 3.7</code>, as in the examples above, and just loop over the coupling strengths in either direction.</p><pre><code class="language-julia hljs">function reproduce_figure_3B()
    Œ≤xys = 0.0:0.025:0.4
    Œ≤yxs = 0.0:0.025:0.4
    œÅxÃÇys = zeros(length(Œ≤xys), length(Œ≤yxs))
    œÅyÃÇxs = zeros(length(Œ≤xys), length(Œ≤yxs))

    for (i, Œ≤xy) in enumerate(Œ≤xys)
        for (j, Œ≤yx) in enumerate(Œ≤yxs)
            sys_bidir = logistic_sugi(; u0 = [0.2, 0.4], rx = 3.7, ry = 3.7, Œ≤xy, Œ≤yx);
            # Generate 300 points. Randomly select a 100-pt long segment.
            x, y = columns(first(trajectory(sys_bidir, 1000, Ttr = 10000)));
            definition = CCM(d = 3, w = 5, œÑ = -1)
            ensemble = Ensemble(RandomVectors(definition; libsizes = 100), nreps = 50)
            œÅxÃÇys[i, j] = mean(crossmap(ensemble, x, y))
            œÅyÃÇxs[i, j] = mean(crossmap(ensemble, y, x))
        end
    end
    Œî = œÅyÃÇxs .- œÅxÃÇys

    with_theme(theme_minimal(),
        markersize = 5) do
        fig = Figure();
        ax = Axis(fig[1, 1], xlabel = &quot;Œ≤xy&quot;, ylabel = &quot;Œ≤yx&quot;)
        cont = contourf!(ax, Œî, levels = range(-1, 1, length = 10),
            colormap = :curl)
        ax.xticks = 1:length(Œ≤xys), string.([i % 2 == 0 ? Œ≤xys[i] : &quot;&quot; for i in 1:length(Œ≤xys)])
        ax.yticks = 1:length(Œ≤yxs), string.([i % 2 == 0 ? Œ≤yxs[i] : &quot;&quot; for i in 1:length(Œ≤yxs)])
        Colorbar(fig[1 ,2], cont, label = &quot;Œî (œÅ(yÃÇ|x) - œÅ(xÃÇ|y))&quot;)
        tightlimits!(ax)
        fig
    end
end

reproduce_figure_3B()</code></pre><img src="ee7934e9.png" alt="Example block output"/><h4 id="Figures-3C-and-3D"><a class="docs-heading-anchor" href="#Figures-3C-and-3D">Figures 3C and 3D</a><a id="Figures-3C-and-3D-1"></a><a class="docs-heading-anchor-permalink" href="#Figures-3C-and-3D" title="Permalink"></a></h4><p>Let&#39;s reproduce figures 3C and 3D in Sugihara et al. (2012)<sup class="footnote-reference"><a id="citeref-Sugihara2012" href="#footnote-Sugihara2012">[Sugihara2012]</a></sup>, which introduced the <a href="../associations/#CausalityTools.ConvergentCrossMapping"><code>ConvergentCrossMapping</code></a> measure. Equations and parameters can be found in their supplementary material. Simulatenously, we also compute the <a href="../associations/#CausalityTools.PairwiseAsymmetricInference"><code>PairwiseAsymmetricInference</code></a> measure from McCracken &amp; Weigel (2014)<sup class="footnote-reference"><a id="citeref-McCracken2014" href="#footnote-McCracken2014">[McCracken2014]</a></sup>, which is a related method, but uses a slightly different embedding.</p><pre><code class="language-julia hljs">using CausalityTools
using Statistics
using LabelledArrays
using StaticArrays
using DynamicalSystemsBase
using StateSpaceSets
using CairoMakie, Printf


# -----------------------------------------------------------------------------------------
# Create 500-point long time series for Sugihara et al. (2012)&#39;s example for figure 3.
# -----------------------------------------------------------------------------------------
sys_unidir = logistic_sugi(; u0 = [0.2, 0.4], rx = 3.7, ry = 3.700001, Œ≤xy = 0.00, Œ≤yx = 0.32);
x, y = columns(first(trajectory(sys_unidir, 500, Ttr = 10000)));

# -----------------------------------------------------------------------------------------
# Cross map.
# -----------------------------------------------------------------------------------------
m_ccm = ConvergentCrossMapping(d = 2)
m_pai = PairwiseAsymmetricInference(d = 2)
# Make predictions xÃÇy, i.e. predictions `xÃÇ` made from embedding of y (AND x, if PAI)
tÃÇccm_xÃÇy, tccm_xÃÇy, œÅccm_xÃÇy = predict(m_ccm, x, y)
tÃÇpai_xÃÇy, tpai_xÃÇy, œÅpai_xÃÇy = predict(m_pai, x, y);
# Make predictions yÃÇx, i.e. predictions `yÃÇ` made from embedding of x (AND y, if PAI)
tÃÇccm_yÃÇx, tccm_yÃÇx, œÅccm_yÃÇx = predict(m_ccm, y, x)
tÃÇpai_yÃÇx, tpai_yÃÇx, œÅpai_yÃÇx = predict(m_pai, y, x);

# -----------------------------------------------------------------------------------------
# Plot results
# -----------------------------------------------------------------------------------------
œÅs = (œÅccm_xÃÇy, œÅpai_xÃÇy, œÅccm_yÃÇx, œÅpai_yÃÇx)
sccm_xÃÇy, spai_xÃÇy, sccm_yÃÇx, spai_yÃÇx = (map(œÅ -&gt; (@sprintf &quot;%.3f&quot; œÅ), œÅs)...,)

œÅs = (œÅccm_xÃÇy, œÅpai_xÃÇy, œÅccm_yÃÇx, œÅpai_yÃÇx)
sccm_xÃÇy, spai_xÃÇy, sccm_yÃÇx, spai_yÃÇx = (map(œÅ -&gt; (@sprintf &quot;%.3f&quot; œÅ), œÅs)...,)

with_theme(theme_minimal(),
    markersize = 5) do
    fig = Figure();
    ax_yÃÇx = Axis(fig[2,1], aspect = 1, xlabel = &quot;y(t) (observed)&quot;, ylabel = &quot;yÃÇ(t) | x (predicted)&quot;)
    ax_xÃÇy = Axis(fig[2,2], aspect = 1, xlabel = &quot;x(t) (observed)&quot;, ylabel = &quot;xÃÇ(t) | y (predicted)&quot;)
    xlims!(ax_yÃÇx, (0, 1)), ylims!(ax_yÃÇx, (0, 1))
    xlims!(ax_xÃÇy, (0, 1)), ylims!(ax_xÃÇy, (0, 1))
    ax_ts = Axis(fig[1, 1:2], xlabel = &quot;Time (t)&quot;, ylabel = &quot;Value&quot;)
    scatterlines!(ax_ts, x[1:300], label = &quot;x&quot;)
    scatterlines!(ax_ts, y[1:300], label = &quot;y&quot;)
    axislegend()
    scatter!(ax_yÃÇx, tccm_yÃÇx, tÃÇccm_yÃÇx, label = &quot;CCM (œÅ = $sccm_yÃÇx)&quot;, color = :black)
    scatter!(ax_yÃÇx, tpai_yÃÇx, tÃÇpai_yÃÇx, label = &quot;PAI (œÅ = $spai_yÃÇx)&quot;, color = :red)
    axislegend(ax_yÃÇx, position = :lt)
    scatter!(ax_xÃÇy, tccm_xÃÇy, tÃÇccm_xÃÇy, label = &quot;CCM (œÅ = $sccm_xÃÇy)&quot;, color = :black)
    scatter!(ax_xÃÇy, tpai_xÃÇy, tÃÇpai_xÃÇy, label = &quot;PAI (œÅ = $spai_xÃÇy)&quot;, color = :red)
    axislegend(ax_xÃÇy, position = :lt)
    fig
end</code></pre><img src="0502462a.png" alt="Example block output"/><h2 id="[PairwiseAsymmetricInference](@ref)"><a class="docs-heading-anchor" href="#[PairwiseAsymmetricInference](@ref)"><a href="../associations/#CausalityTools.PairwiseAsymmetricInference"><code>PairwiseAsymmetricInference</code></a></a><a id="[PairwiseAsymmetricInference](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[PairwiseAsymmetricInference](@ref)" title="Permalink"></a></h2><h3 id="Reproducing-McCracken-and-Weigel-(2014)"><a class="docs-heading-anchor" href="#Reproducing-McCracken-and-Weigel-(2014)">Reproducing McCracken &amp; Weigel (2014)</a><a id="Reproducing-McCracken-and-Weigel-(2014)-1"></a><a class="docs-heading-anchor-permalink" href="#Reproducing-McCracken-and-Weigel-(2014)" title="Permalink"></a></h3><p>Let&#39;s try to reproduce figure 8 from <a href="../references/#McCracken2014">McCracken and Weigel (2014)</a>&#39;s paper on <a href="../associations/#CausalityTools.PairwiseAsymmetricInference"><code>PairwiseAsymmetricInference</code></a> (PAI). We&#39;ll start by defining the their example B (equations 6-7). This system consists of two variables <span>$X$</span> and <span>$Y$</span>, where <span>$X$</span> drives <span>$Y$</span>.</p><p>After we have computed the PAI in both directions, we define a measure of directionality as the difference between PAI in the <span>$X \to Y$</span> direction and in the <span>$Y \to X$</span> direction, so that if <span>$X$</span> drives <span>$Y$</span>, then <span>$\Delta &lt; 0$</span>.</p><pre><code class="language-julia hljs">using CausalityTools
using LabelledArrays
using StaticArrays
using DynamicalSystemsBase
using StateSpaceSets
using CairoMakie, Printf
using Distributions: Normal
using Statistics: mean, std

function eom_nonlinear_sindriver(dx, x, p, n)
    a, b, c, t, Œît = (p...,)
    x, y = x[1], x[2]
    ùí© = Normal(0, 1)

    dx[1] = sin(t)
    dx[2] = a*x * (1 - b*x) + c* rand(ùí©)
    p[end-1] += 1 # update t

    return
end

function nonlinear_sindriver(;u‚ÇÄ = rand(2), a = 1.0, b = 1.0, c = 2.0, Œît = 1)
    DiscreteDynamicalSystem(eom_nonlinear_sindriver, u‚ÇÄ, [a, b, c, 0, Œît])
end

function reproduce_figure_8_mccraken(;
        c = 2.0, Œît = 0.2,
        as = 0.5:0.5:5.0,
        bs = 0.5:0.5:5.0)
    # -----------------------------------------------------------------------------------------
    # Generate many time series for many different values of the parameters `a` and `b`,
    # and compute PAI. This will replicate the upper right panel of
    # figure 8 in McCracken &amp; Weigel (2014).
    # -----------------------------------------------------------------------------------------

    measure = PairwiseAsymmetricInference(d = 3)

    # Manually resample `nreps` length-`L` time series and use mean œÅ(xÃÇ|XÃÑy) - œÅ(yÃÇ|YÃÑx)
    # for each parameter combination.
    nreps = 50
    L = 200 # length of timeseries
    Œî = zeros(length(as), length(bs))
    for (i, a) in enumerate(as)
        for (j, b) in enumerate(bs)
            s = nonlinear_sindriver(; a, b, c,  Œît)
            x, y = columns(first(trajectory(s, 1000, Ttr = 10000)))
            Œîreps = zeros(nreps)
            for i = 1:nreps
                # Ensure we&#39;re subsampling at the same time indices.
                ind_start = rand(1:(1000-L))
                r = ind_start:(ind_start + L)
                Œîreps[i] = @views crossmap(measure, y[r], x[r]) -
                    crossmap(measure, x[r], y[r])
            end
            Œî[i, j] = mean(Œîreps)
        end
    end

    # -----------------------------------------------------------------------------------------
    # An example time series for plotting.
    # -----------------------------------------------------------------------------------------
    sys = nonlinear_sindriver(; a = 1.0, b = 1.0, c, Œît)
    npts = 500
    orbit = first(trajectory(sys, npts, Ttr = 10000))
    x, y = columns(orbit)
    with_theme(theme_minimal(),
        markersize = 5) do

        X = x[1:300]
        Y = y[1:300]
        fig = Figure();
        ax_ts = Axis(fig[1, 1:2], xlabel = &quot;Time (t)&quot;, ylabel = &quot;Value&quot;)
        scatterlines!(ax_ts, (X .- mean(X)) ./ std(X), label = &quot;x&quot;)
        scatterlines!(ax_ts, (Y .- mean(Y)) ./ std(Y), label = &quot;y&quot;)
        axislegend()

        ax_hm = Axis(fig[2, 1:2], xlabel = &quot;a&quot;, ylabel = &quot;b&quot;)
        ax_hm.yticks = (1:length(as), string.([i % 2 == 0 ? as[i] : &quot;&quot; for i = 1:length(as)]))
        ax_hm.xticks = (1:length(bs), string.([i % 2 == 0 ? bs[i] : &quot;&quot; for i = 1:length(bs)]))
        hm = heatmap!(ax_hm, Œî,  colormap = :viridis)
        Colorbar(fig[2, 3], hm; label = &quot;Œî&#39; = œÅ(yÃÇ | yx) - œÅ(xÃÇ | xy)&quot;)
        fig
    end
end

reproduce_figure_8_mccraken()</code></pre><img src="ff64814b.png" alt="Example block output"/><p>We haven&#39;t used as many parameter combinations as <a href="../references/#McCracken2014">McCracken and Weigel (2014)</a> did,  but we get a figure that looks roughly similar to theirs.</p><p>As expected, <span>$\Delta &lt; 0$</span> for all parameter combinations, implying that <span>$X$</span> &quot;PAI drives&quot; <span>$Y$</span>.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Sugihara2012"><a class="tag is-link" href="#citeref-Sugihara2012">Sugihara2012</a>Sugihara, G., May, R., Ye, H., Hsieh, C. H., Deyle, E., Fogarty, M., &amp; Munch, S. (2012). Detecting causality in complex ecosystems. science, 338(6106), 496-500.</li><li class="footnote" id="footnote-McCracken2014"><a class="tag is-link" href="#citeref-McCracken2014">McCracken2014</a>McCracken, J. M., &amp; Weigel, R. S. (2014). Convergent cross-mapping and pairwise asymmetric inference. Physical Review E, 90(6), 062903.</li></ul></section></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Wednesday 24 July 2024 01:54">Wednesday 24 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
