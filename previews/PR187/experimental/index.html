<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Experimental · CausalityTools.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CausalityTools.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><span class="tocitem">Information measures</span><ul><li><a class="tocitem" href="../probabilities/">Probability mass functions</a></li><li><a class="tocitem" href="../entropy/">Entropy</a></li><li><a class="tocitem" href="../entropy_conditional/">Conditional entropy</a></li><li><a class="tocitem" href="../mutualinfo/">Mutual information</a></li><li><a class="tocitem" href="../condmutualinfo/">Conditional mutual information</a></li><li><a class="tocitem" href="../transferentropy/">Transfer entropy</a></li></ul></li><li><a class="tocitem" href="../cross_mappings/">Cross mappings</a></li><li><a class="tocitem" href="../jdd/">Joint distance distribution</a></li><li class="is-active"><a class="tocitem" href>Experimental</a><ul class="internal"><li><a class="tocitem" href="#Predictive-asymmetry"><span>Predictive asymmetry</span></a></li><li><a class="tocitem" href="#Independence-testing"><span>Independence testing</span></a></li><li><a class="tocitem" href="#Automated-embedding-for-transfer-entropy"><span>Automated embedding for transfer entropy</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Experimental</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Experimental</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/CausalityTools.jl/blob/master/docs/src/experimental.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="[Experimental](@ref-experimental_methods)"><a class="docs-heading-anchor" href="#[Experimental](@ref-experimental_methods)"><a href="@ref experimental_methods">Experimental</a></a><a id="[Experimental](@ref-experimental_methods)-1"></a><a class="docs-heading-anchor-permalink" href="#[Experimental](@ref-experimental_methods)" title="Permalink"></a></h1><p>Here we list implemented methods that do not yet appear in peer-reviewed journals, but are found, for example, in pre-print servers like <a href="https://arxiv.org/">arXiv</a>.</p><p>The API for these methods, and their return values, may change at any time until they appear as part of the public API. Use them wisely.</p><h2 id="Predictive-asymmetry"><a class="docs-heading-anchor" href="#Predictive-asymmetry">Predictive asymmetry</a><a id="Predictive-asymmetry-1"></a><a class="docs-heading-anchor-permalink" href="#Predictive-asymmetry" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CausalityTools.predictive_asymmetry" href="#CausalityTools.predictive_asymmetry"><code>CausalityTools.predictive_asymmetry</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">predictive_asymmetry(estimator::TransferEntropyEstimator, ηs; s, t, [c],
    dTf = 1, dT = 1, dS = 1, τT = -1, τS = -1, [dC = 1, τC = -1],
    normalize::Bool = false, f::Real = 1.0, base = 2) → Vector{Float64}</code></pre><p>Compute the predictive asymmetry<sup class="footnote-reference"><a id="citeref-Haaga2020" href="#footnote-Haaga2020">[Haaga2020]</a></sup> 𝔸(<code>s</code> → <code>t</code>) for source time series <code>s</code> and target time series <code>t</code> over prediction lags <code>ηs</code>, using the given <code>estimator</code> and embedding parameters <code>dTf</code>, <code>dT</code>, <code>dS</code>, <code>τT</code>, <code>τS</code> (see also <a href="../transferentropy/#CausalityTools.EmbeddingTE"><code>EmbeddingTE</code></a>)</p><p>If a conditional time series <code>c</code> is provided, compute 𝔸(<code>s</code> → <code>t</code> | <code>c</code>). Then, <code>dC</code> and <code>τC</code> controls the embedding dimension and embedding lag for the conditional variable.</p><p><strong>Returns</strong></p><p>Returns a vector containing the predictive asymmetry for each value of <code>ηs</code>.</p><p><strong>Normalization (hypothesis test)</strong></p><p>If <code>normalize == true</code> (the default), then compute the normalized predictive asymmetry 𝒜. In this case, for each <span>$\eta$</span> in <code>ηs</code>, compute 𝒜(η) by normalizing 𝔸(η) to some fraction <code>f</code> of the mean transfer entropy over prediction lags <span>$-\eta, ..., \eta$</span> (exluding lag 0). Haaga et al. (2020)<sup class="footnote-reference"><a id="citeref-Haaga2020" href="#footnote-Haaga2020">[Haaga2020]</a></sup> uses a normalization with <code>f=1.0</code> as a built-in hypothesis test, avoiding more computationally costly surrogate testing.</p><p><strong>Estimators</strong></p><p>Any <a href="@ref">estimator</a> that works for <a href="../transferentropy/#CausalityTools.transferentropy"><code>transferentropy</code></a> will also work with <code>predictive_asymmetry</code>. Check the online documentation for compatiable estimators.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using CausalityTools
# Some example time series
x, y = rand(100), rand(100)
# 𝔸(x → y) over prediction lags 1:5
𝔸reg  = predictive_asymmetry(x, y, VisitationFrequency(RectangularBinning(5)), 1:5)</code></pre><div class="admonition is-info"><header class="admonition-header">Experimental!</header><div class="admonition-body"><p>This is a method that does not yet appear in a peer-reviewed scientific journal. Feel free to use, but consider it experimental for now. It will reappear in a 2.X release in new form once published in a peer-reviewed journal.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CausalityTools.jl/blob/f8d88bf95b9ad4cd5d608dae66708a395c9b325f/src/deprecations/predictive_asymmetry.jl#L38-L86">source</a></section></article><h2 id="Independence-testing"><a class="docs-heading-anchor" href="#Independence-testing">Independence testing</a><a id="Independence-testing-1"></a><a class="docs-heading-anchor-permalink" href="#Independence-testing" title="Permalink"></a></h2><p>A common application of information theoretic methods such as conditional mutual information (<a href="../condmutualinfo/#CausalityTools.condmutualinfo-Tuple{ConditionalMutualInformationEstimator, Any, Any, Any}"><code>condmutualinfo</code></a>) is in the context of null hypothesis testing for the conditional independence of variables.</p><p>Depending on the context, the input data and the method used, there are many considerations to be made about how to perform this conditional independence testing. Luckily, many excellent frameworks for doing so exist in the literature.</p><p>Here, we present some commonly used independence tests from the scientific literature, which can all be seamlessly used with the function <a href="#CausalityTools.independence"><code>independence</code></a>, with <em>any</em> measure that quantifies conditional independence, in combination with <em>any</em> compatible estimator.</p><p>For example, in just a few lines of code, you can perform Runge&#39;s local permutation (<a href="#CausalityTools.LocalPermutation"><code>LocalPermutation</code></a> test on your data with <em>over 20 different estimators</em> for the conditional mutual information. If your application rather calls for the use of traditional <a href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl">surrogate data</a>, the <a href="#CausalityTools.SurrogateCIT"><code>SurrogateCIT</code></a> test seamlessly integrates with any time series surrogate method from TimeseriesSurrogates.jl.</p><h3 id="Independence-test-API"><a class="docs-heading-anchor" href="#Independence-test-API">Independence test API</a><a id="Independence-test-API-1"></a><a class="docs-heading-anchor-permalink" href="#Independence-test-API" title="Permalink"></a></h3><p>The independence test API is defined by</p><ul><li><a href="#CausalityTools.independence"><code>independence</code></a></li><li><a href="@ref"><code>IndependenceTest</code></a></li><li><a href="#CausalityTools.ConditionalIndependenceTest"><code>ConditionalIndependenceTest</code></a></li></ul><h3 id="Independence-tests"><a class="docs-heading-anchor" href="#Independence-tests">Independence tests</a><a id="Independence-tests-1"></a><a class="docs-heading-anchor-permalink" href="#Independence-tests" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CausalityTools.independence" href="#CausalityTools.independence"><code>CausalityTools.independence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">independence(test, x, y, [z])</code></pre><p>Perform the given <code>test</code> of independence between <code>x</code> and <code>y</code> using the provided <code>test</code>. If <code>z</code> is given, compute the conditional independence of <code>x</code> and <code>y</code> given <code>z</code>.</p><p>This function is just a generic implementation of a one-sided hypothesis test, where the null hypothesis is that <code>x</code> and <code>y</code> are independent (given <code>z</code>, if provided).</p><p><strong>Supported tests</strong></p><p>The null hypothesis is specified by <code>test</code>, which is a <a href="@ref"><code>IndependenceTest</code></a>.</p><ul><li><a href="#CausalityTools.LocalPermutation"><code>LocalPermutation</code></a></li><li><a href="#CausalityTools.SurrogateCIT"><code>SurrogateCIT</code></a>. This is essentially a convenience wrapper that performs   standard surrogate testing.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CausalityTools.jl/blob/f8d88bf95b9ad4cd5d608dae66708a395c9b325f/src/independence_tests/conditional/conditional_independence.jl#L14-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CausalityTools.ConditionalIndependenceTest" href="#CausalityTools.ConditionalIndependenceTest"><code>CausalityTools.ConditionalIndependenceTest</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConditionalIndependenceTest &lt;: IndependenceTest</code></pre><p>The supertype for all conditional independence tests, which are:</p><ul><li><a href="#CausalityTools.LocalPermutation"><code>LocalPermutation</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CausalityTools.jl/blob/f8d88bf95b9ad4cd5d608dae66708a395c9b325f/src/independence_tests/conditional/conditional_independence.jl#L5-L11">source</a></section></article><h4 id="Surrogate-test-(global-permutation)"><a class="docs-heading-anchor" href="#Surrogate-test-(global-permutation)">Surrogate test (global permutation)</a><a id="Surrogate-test-(global-permutation)-1"></a><a class="docs-heading-anchor-permalink" href="#Surrogate-test-(global-permutation)" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="CausalityTools.SurrogateCIT" href="#CausalityTools.SurrogateCIT"><code>CausalityTools.SurrogateCIT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SurrogateCIT &lt;: IndependenceTest
SurrogateCIT(;
    measure = CMIShannon(),
    est = FPVP(k = 5),
    nsurr::Int = 100,
    surrogate = RandomShuffle(),
    rng = Random.MersenneTwister(1234),
)</code></pre><p>The <code>SurrogateCIT</code> test is a generic conditional independence test (CIT) for assessing whether two variables <code>X</code> and <code>Y</code> are conditionally independendent given a third variable <code>Z</code>. It uses <a href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl">surrogate time series</a> to generate the null distribution.</p><p><strong>Null hypotheses</strong></p><ul><li>If used with a <a href="../condmutualinfo/#CausalityTools.ConditionalMutualInformation"><code>ConditionalMutualInformation</code></a> measure such as   <a href="../condmutualinfo/#CausalityTools.CMIShannon"><code>CMIShannon</code></a>, then the shuffled variable is the first input <code>X</code>.</li><li>If used with a <a href="../transferentropy/#CausalityTools.TransferEntropy"><code>TransferEntropy</code></a> measure such as   <a href="../transferentropy/#CausalityTools.TEShannon"><code>TEShannon</code></a>, then the shuffled variable is the first input <code>X</code>, i.e.   the source variable.</li></ul><p><strong>Example usage</strong></p><p>Here, we&#39;ll test if the transfer entropy from <code>x</code> to <code>y</code> is significant. If we can reject the null hypothesis that <code>x</code> and <code>y</code> are independent, then we take that as evidence that <code>x</code> influences <code>y</code>.</p><pre><code class="language-julia hljs">using CausalityTools
# If `x` and `y` were dependent given `z`, then we&#39;d expect to be able to reject the
# null hypothesis that x ⫫ y | z.
sys = logistic2_unidir(c_xy = 0.5)
npts = 1000
x, y = columns(trajectory(sys, npts, Ttr = npts*10))
test = SurrogateCIT(TEShannon(), FPVP(k = 10))
independence(test, x, y)

# If `x` and `y` are *independent*.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CausalityTools.jl/blob/f8d88bf95b9ad4cd5d608dae66708a395c9b325f/src/independence_tests/conditional/surrogate/SurrogateCIT.jl#L5-L48">source</a></section></article><h4 id="Local-permutation"><a class="docs-heading-anchor" href="#Local-permutation">Local permutation</a><a id="Local-permutation-1"></a><a class="docs-heading-anchor-permalink" href="#Local-permutation" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="CausalityTools.LocalPermutation" href="#CausalityTools.LocalPermutation"><code>CausalityTools.LocalPermutation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LocalPermutation &lt;: ConditionalIndependenceTest
LocalPermutation(measure = CMIShannon(), est = FPVP(k = 5);
    kperm::Int = 5,
    nsurr::Int = 100,
    rng = Random.MersenneTwister(1234))</code></pre><p>A generic implementation of the <code>LocalPermutation</code> test  (Runge, 2018)<sup class="footnote-reference"><a id="citeref-Runge2018" href="#footnote-Runge2018">[Runge2018]</a></sup>, which tests whether two variables <code>X</code> and <code>Y</code> are conditionally independendent given a third variable <code>Z</code> (all of which may be multivariate).</p><p>You can use any valid combination of <code>definition</code>, <code>measure</code> and <code>est</code> that yields a conditional dependence measure <span>$\hat{M}(X; Y | Z)$</span> with the same ordering as <a href="../condmutualinfo/#CausalityTools.condmutualinfo-Tuple{ConditionalMutualInformationEstimator, Any, Any, Any}"><code>condmutualinfo</code></a> (i.e. the conditional variable (<code>Z</code>) is the third input variable). The default measure is Shannon conditional mutual information <a href="../condmutualinfo/#CausalityTools.CMIShannon"><code>CMIShannon</code></a>, <span>$I(X; Y | Z)$</span> with the nearest-neighbor based <a href="@ref]"><code>FPVP</code></a> differential CMI estimator.</p><p><strong>Description</strong></p><p><code>LocalPermutation</code> creates permuted <code>X</code> values using a local permutation scheme that is based on <code>kperm</code>-th nearest neighbor searches. Permuted points are constructed as <span>$(x_i^*, y_i, z_i)_{i=1}^N$</span>, where the goal is that <span>$x_i^*$</span> are drawn without replacement, and <span>$x_i$</span> is replaced by <span>$x_j$</span> only if <span>$z_i \approx z_j$</span>. Then, for each permuted version of <code>X</code>, it computes the original statistic on the permuted data, keeping <code>Y</code> and <code>Z</code> fixed, i.e. <span>$\hat{M}(\hat{X}; Y | Z)$</span>.</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs">x = randn(2000)
y = randn(2000) .+ 0.7 .* x
z = sin.(randn(2000)) .* 0.5 .* y
test = LocalPermutation(CMIShannon(; base = 2), FPVP(k = 10))
independence(test, x, y, z)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CausalityTools.jl/blob/f8d88bf95b9ad4cd5d608dae66708a395c9b325f/src/independence_tests/conditional/local_permutation/LocalPermutation.jl#L8-L47">source</a></section></article><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><h4 id="[LocalPermutation](@ref)"><a class="docs-heading-anchor" href="#[LocalPermutation](@ref)"><a href="#CausalityTools.LocalPermutation"><code>LocalPermutation</code></a></a><a id="[LocalPermutation](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[LocalPermutation](@ref)" title="Permalink"></a></h4><p>Here, we&#39;ll create a three-variable scenario where <code>X</code> and <code>Z</code> are connected through <code>Y</code>, so that <span>$I(X; Z | Y) = 0$</span> and <span>$I(X; Y | Z) &gt; 0$</span>. We&#39;ll test for conditional independence using Shannon conditional mutual information (<a href="../condmutualinfo/#CausalityTools.CMIShannon"><code>CMIShannon</code></a>). To estimate CMI, we&#39;ll use the <a href="../entropy/#ComplexityMeasures.Kraskov"><code>Kraskov</code></a> differential entropy estimator, which naively computes CMI as a sum of entropy terms without guaranteed bias cancellation.</p><pre><code class="language-julia hljs">using CausalityTools

X = randn(1000)
Y = X .+ randn(1000) .* 0.4
Z = randn(1000) .+ Y
x, y, z = Dataset.((X, Y, Z))
test = LocalPermutation(CMIShannon(base = 2), Kraskov(k = 10), nsurr = 30)
test_result = independence(test, x, y, z)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">`LocalPermutation` independence test
----------------------------------------------------------------------------------
H₀: &quot;The first two variables are conditionally independent given the third&quot;
----------------------------------------------------------------------------------
Estimated: 0.432551591633928
Ensemble quantiles (30 permutations):
  (99.9%): 0.004668358065417452
  (99%):   0.004401725585744441
  (95%):   0.0011608347945485636
p-value:   0.0
  H₀ rejected at α = 0.05:  Yes ✅
  H₀ rejected at α = 0.01:  Yes ✅
  H₀ rejected at α = 0.001: Yes ✅</code></pre><p>We expect there to be a detectable influence from <span>$X$</span> to <span>$Y$</span>, if we condition on <span>$Z$</span> or not, because <span>$Z$</span> doesn&#39;t influence neither <span>$X$</span> nor <span>$Y$</span>. The null hypothesis is that the first two variables are conditionally independent given the third, which we reject with a very low p-value. Hence, we accept the alternative hypothesis that the first two variables <span>$X$</span> and <span>$Y$</span>. are conditionally <em>dependent</em> given <span>$Z$</span>.</p><pre><code class="language-julia hljs">test_result = independence(test, x, z, y)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">`LocalPermutation` independence test
----------------------------------------------------------------------------------
H₀: &quot;The first two variables are conditionally independent given the third&quot;
----------------------------------------------------------------------------------
Estimated: -0.024075254737095264
Ensemble quantiles (30 permutations):
  (99.9%): 0.0016749342584386241
  (99%):   0.00023808299282294335
  (95%):   -0.004618503528311589
p-value:   0.6666666666666666
  H₀ rejected at α = 0.05:  No  ❌
  H₀ rejected at α = 0.01:  No  ❌
  H₀ rejected at α = 0.001: No  ❌</code></pre><p>As expected, we cannot reject the null hypothesis that <span>$X$</span> and <span>$Z$</span> are conditionally independent given <span>$Y$</span>, because <span>$Y$</span> is the variable that transmits information from <span>$X$</span> to <span>$Z$</span>.</p><h4 id="[SurrogateCIT](@ref)"><a class="docs-heading-anchor" href="#[SurrogateCIT](@ref)"><a href="#CausalityTools.SurrogateCIT"><code>SurrogateCIT</code></a></a><a id="[SurrogateCIT](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[SurrogateCIT](@ref)" title="Permalink"></a></h4><p>To demonstrate the <a href="#CausalityTools.SurrogateCIT"><code>SurrogateCIT</code></a> test, we use the transfer entropy measure, which accepts either two input timeseries, or three timeseries when computing the partial/conditional transfer entropy.</p><pre><code class="language-julia hljs">using CausalityTools
sys = logistic2_unidir(c_xy = 0.5) # x affects y, but not the other way around.
x, y = columns(trajectory(sys, 1000, Ttr = 10000))

test = SurrogateCIT(TEShannon(), KSG1(k = 4))
independence(test, x, y)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">`SurrogateCIT` independence test result
-----------------------------------------------------------------------------------
H₀: &quot;The first two variables are independent (given the 3rd variable, if relevant)&quot;
Hₐ: &quot;The first two variables are dependent (given the 3rd variable, if relevant)&quot;
-----------------------------------------------------------------------------------
Estimated: 1.2878586270076275
Ensemble quantiles (100 permutations):
  (99.9%): 0.6890197450381296
  (99%):   0.6786060026795824
  (95%):   0.6673634762250779
p-value:   0.0
  H₀ rejected at α = 0.05:  Yes ✅
  H₀ rejected at α = 0.01:  Yes ✅
  H₀ rejected at α = 0.001: Yes ✅</code></pre><p>As expected, we can reject the null hypothesis that the future of <code>y</code> is independent of  <code>x</code>, because <code>x</code> does actually influence <code>y</code>. This doesn&#39;t change if we compute  partial transfer entropy with respect to some random extra time series, because it doesn&#39;t influence either variables.</p><pre><code class="language-julia hljs">independence(test, x, y, rand(length(x)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">`SurrogateCIT` independence test result
-----------------------------------------------------------------------------------
H₀: &quot;The first two variables are independent (given the 3rd variable, if relevant)&quot;
Hₐ: &quot;The first two variables are dependent (given the 3rd variable, if relevant)&quot;
-----------------------------------------------------------------------------------
Estimated: 0.5593817615003804
Ensemble quantiles (100 permutations):
  (99.9%): 0.5112567506764502
  (99%):   0.506537007792058
  (95%):   0.49438932005156394
p-value:   0.0
  H₀ rejected at α = 0.05:  Yes ✅
  H₀ rejected at α = 0.01:  Yes ✅
  H₀ rejected at α = 0.001: Yes ✅</code></pre><h2 id="Automated-embedding-for-transfer-entropy"><a class="docs-heading-anchor" href="#Automated-embedding-for-transfer-entropy">Automated embedding for transfer entropy</a><a id="Automated-embedding-for-transfer-entropy-1"></a><a class="docs-heading-anchor-permalink" href="#Automated-embedding-for-transfer-entropy" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>bbnue</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Haaga2020"><a class="tag is-link" href="#citeref-Haaga2020">Haaga2020</a>Haaga, Kristian Agasøster, David Diego, Jo Brendryen, and Bjarte Hannisdal. &quot;A simple test for causality in complex systems.&quot; arXiv preprint arXiv:2005.01860 (2020).</li><li class="footnote" id="footnote-Runge2018"><a class="tag is-link" href="#citeref-Runge2018">Runge2018</a>Runge, J. (2018, March). Conditional independence testing based on a nearest-neighbor estimator of conditional mutual information. In International Conference on Artificial Intelligence and Statistics (pp. 938-947). PMLR.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../jdd/">« Joint distance distribution</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 19 January 2023 00:38">Thursday 19 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
