using Distributions: Normal
using DynamicalSystemsBase: ContinuousDynamicalSystem
using Random

export ChuaScrollSine3

"""
    ChuaScrollSine3 <: ContinuousDefinition
    ChuaScrollSine3(; xi = [0.1, 0.2, 0.3],
        α = 10.814, β = 14, γ = 0, a = 1.3, b = 0.11, c = 2,
        nx = Normal(0.0, 0.01),
        ny = Normal(0.0, 0.01)
        nz = Normal(0.0, 0.01))

An adjusted Chua system giving rise to n-scroll attractors (Tang et al., 2001)[^Tang2001].

## Description

The dynamics is generated by the following vector field

```math
\\begin{align*}
\\dot{x} &= \\alpha (y - fx) + \\eta x \\\\
\\dot{y} &= x - y + z + \\eta y \\\\
\\dot{z} &= -\\beta y - \\gamma z + \\eta z
\\end{align*}
```

where ``\\eta x``, ``\\eta z``, and ``\\eta z`` are drawn independently from
normal distributions `nx`, `ny` and `nz` each iteration.

``fx`` is given by the following conditions:

```julia
n::Int = c + 1

if x >= 2*a*c
    fx = (b*pi/2*a)*(x - 2*a*c)
elseif -2*a*c < x < 2*a*c
    d = ifelse(isodd(n), pi, 0)
    fx = -b*sin((pi*x/2*a) + d)
elseif x <= -2*a*c
    fx = (b*pi/2*a)*(x + 2*a*c)
end
```

[^Tang2001]:
    Tang, Wallace KS, et al. "Generation of n-scroll attractors via
    sine function." IEEE Transactions on Circuits and Systems I:
    Fundamental Theory and Applications 48.11 (2001): 1369-1372.
"""
Base.@kwdef struct ChuaScrollSine3{V,A,B,Y,Q,R,C,NX,NY,NZ,RNG} <: ContinuousDefinition
    xi::V = [0.1, 0.2, 0.3]
    α::A = 10.814
    β::B = 14
    γ::Y = 0
    a::Q = 1.3
    b::R = 0.11
    c::C = 2
    nx::NX = Normal(0.0, 0.01)
    ny::NY = Normal(0.0, 0.01)
    nz::NZ = Normal(0.0, 0.01)
    rng::RNG = Random.default_rng()
end

function system(definition::ChuaScrollSine3)
    return ContinuousDynamicalSystem(eom_chuascrollsine3, definition.xi, definition)
end

@inline @inbounds function eom_chuascrollsine3(u, p, t)
    (; xi, α, β, γ, a, b, c, nx, ny, nz, rng) = p
    x, y, z = u

    n::Int = c + 1
    if x >= 2*a*c
        fx = (b*pi/2*a)*(x - 2*a*c)
    elseif -2*a*c < x < 2*a*c
        d = ifelse(isodd(n), pi, 0)
        fx = -b*sin((pi*x/2*a) + d)
    elseif x <= -2*a*c
        fx = (b*pi/2*a)*(x + 2*a*c)
    end

    ηx = rand(rng, nx)
    ηy = rand(rng, ny)
    ηz = rand(rng, nz)

    dx = α*(y - fx) + ηx
    dy = x - y + z + ηy
    dz = -β*y - γ*z + ηz
    return SVector{3}(dx, dy, dz)
end
