using LabelledArrays: @LArray
using StaticArrays: SVector
using DynamicalSystemsBase: trajectory
using DynamicalSystemsBase: ContinuousDynamicalSystem
using SimpleDiffEq: SimpleATsit5

export rossler_rossler
export rossler_lorenz
export lorenz_lorenz_bidir
export chuacircuits_driven
export lorenz_lorenz_lorenz_bidir_forced
export lorenz_lorenz_lorenz_transitive
export lorenzdiffusive
export rossler_rossler_rossler_bidir_forced
export mediated_link
export rossler_rossler_bidir
export chuacircuit_nscroll_sine

@inline @inbounds function eom_chuacircuit_nscroll_sine(u, p, t)
    α, β, γ, a, b, c, σx, σy, σz = (p...,)
    x, y, z = u

    n::Int = c + 1
    if x >= 2*a*c
        fx = (b*pi/2*a)*(x - 2*a*c)
    elseif -2*a*c < x < 2*a*c
        d = ifelse(isodd(n), pi, 0)
        fx = -b*sin((pi*x/2*a) + d)
    elseif x <= -2*a*c
        fx = (b*pi/2*a)*(x + 2*a*c)
    end

    ηx = σx == 0 ? 0 : rand(Normal(0, σx))
    ηy = σy == 0 ? 0 : rand(Normal(0, σy))
    ηz = σz == 0 ? 0 : rand(Normal(0, σz))

    dx = α*(y - fx) + ηx
    dy = x - y + z + ηy
    dz = -β*y - γ*z + ηz
    return SVector{3}(dx, dy, dz)
end

function chuacircuit_nscroll_sine(u₀, α, β, γ, a, b, c::Int, σx, σy, σz)
    @warn "`chuacircuit_nscroll_sine` is deprecated in CausalityTools v2. "*
    "Use `system(ChuaScrollSine3())` instead, which returns a "*
    "`ContinuousDynamicalSystem` that can be iterated."
    p = @LArray [α, β, γ, a, b, c, σx, σy, σz] (:α, :β, :γ, :a, :b, :c, :σx, :σy, :σz)
    ContinuousDynamicalSystem(eom_chuacircuit_nscroll_sine, u₀, p)
end

"""
    chuacircuit_nscroll_sine(;u₀ = [0.0, 0.0, 0.28695],
        α = 10.814, β = 14, γ = 0, a = 1.3, b = 0.11, c = 2,
        σx = 0.0, σy = 0.0, σz = 0.0)

Initialise an adjusted Chua system giving rise to n-scroll attractors [1].

## Equations of motion

The dynamics is generated by the following vector field

```math
\\begin{aligned}
\\dot{x} = \\alpha (y - fx) + \\eta x \\\\
\\dot{y} = x - y + z + \\eta y \\\\
\\dot{z} = -\\beta y - \\gamma z + \\eta z
\\end{aligned}
```

where ``\\eta x``, ``\\eta z``, and ``\\eta z`` are drawn independently from
normal distributions with zero mean and standard deviations `σx`, `σy`
and `σz` at each iteration.

``fx`` is given by the following conditions:

```julia
n::Int = c + 1

if x >= 2*a*c
    fx = (b*pi/2*a)*(x - 2*a*c)
elseif -2*a*c < x < 2*a*c
    d = ifelse(isodd(n), pi, 0)
    fx = -b*sin((pi*x/2*a) + d)
elseif x <= -2*a*c
    fx = (b*pi/2*a)*(x + 2*a*c)
end
```

## References

1. Tang, Wallace KS, et al. "Generation of n-scroll attractors via
    sine function." IEEE Transactions on Circuits and Systems I:
    Fundamental Theory and Applications 48.11 (2001): 1369-1372.
"""
chuacircuit_nscroll_sine(;u₀ = [0.0, 0.0, 0.28695],
        α = 10.814, β = 14, γ = 0, a = 1.3, b = 0.11, c = 2,
        σx = 0.0, σy = 0.0, σz = 0.0) =
    chuacircuit_nscroll_sine(u₀, α, β, γ, a, b, c, σx, σy, σz)

"""
    eom_rossler_rossler(u, p, t) → Function

Equations of motions for a 6D dynamical system consisting
of two 3D Rössler attractors.
"""
function eom_rossler_rossler(u, p, t)
    a, b, c, ϵ₁, ϵ₂, ω₁, ω₂ = ([p[i] for i = 1:7]...,)
    x₁, y₁, z₁, x₂, y₂, z₂ = ([u[i] for i = 1:6]...,)
    # First Rössler system
    dx₁ = ω₁*(-y₁) - z₁ + ϵ₂*(x₁ - x₂)
    dy₁ = ω₁*x₁ + a*y₁
    dz₁ = b + z₁*(x₁ - c)

    # Second Rössler system
    dx₂ = ω₂*(-y₂) - z₂ + ϵ₁*(x₂ - x₁)
    dy₂ = ω₂*x₂ + a*y₂
    dz₂ = b + z₂*(x₂ - c)
    return SVector{6}(dx₁, dy₁, dz₁, dx₂, dy₂, dz₂)
end

"""
	rossler_rossler(u₀, a, b, c, ϵ₁, ϵ₂, ω₁, ω₂) → ContinuousDynamicalSystem

A coupled 6D Rossler system from Krakovská et al. (2018).
The system consists of two separate subsystems, each being a 3D Rossler
attractor. The subsystems are bidirectionally coupled, influencing each other
through variables `x₁` and `x₂`.

The parameters and default values (if calling the keyword version of `rrbi`)
are as follows:

```
a = 0.1      # parameter in the Rössler attractor
b = 0.1      # parameter in the Rössler attractor
c = 14.0     # parameter in the Rössler attractor
ϵ₁ = 0.0     # influence of subsystem 1 on subsystem 2
ϵ₂ = 0.0     # influence of subsystem 2 on subsystem 1
ω₁ = 1+0.015 # the frequency of the first system
ω₂ = 1-0.015 # the frequency of the second system
```

The dynamics is generated by the vector field:

```math
\\begin{aligned}
\\dot x₁ = ω₁ (-y₁) - z₁ + ϵ₂(x₁ - x₂)
\\dot y₁ = ω₁ x₁ + ay₁
\\dot z₁ = b + z₁(x₁ - c)

\\dot x₂ = ω₂(-y₂) - z₂ + ϵ₁(x₂ - x₁)
\\dot y₂ = ω₂x₂ + ay₂
\\dot z₂ = b + z₂(x₂ - c)
\\end{aligned}
```

with the coupling constant ``c \\geq 0``.

# References
Krakovská, A., Jakubík, J., Chvosteková, M., Coufal, D., Jajcay, N., & Paluš, M. (2018). Comparison of six methods for the detection of causality in a bivariate time series. Physical Review E, 97(4), 042207.
"""
function rossler_rossler(u₀, a, b, c, ϵ₁, ϵ₂, ω₁, ω₂)
    @warn "`rossler_rossler` is deprecated in CausalityTools v2. "*
    "Use `system(RosslerRossler6())` instead, which returns a "*
    "`ContinuousDynamicalSystem` that can be iterated."
    p = @LArray [a, b, c, ϵ₁, ϵ₂, ω₁, ω₂] (:a, :b, :c, :ϵ₁, :ϵ₂, :ω₁, :ω₂)
    return ContinuousDynamicalSystem(eom_rossler_rossler, u₀, p)
end

"""
	rossler_rossler(;u₀ = rand(6), a = 0.1, b = 0.1, c = 14.0, ϵ₁ = 0.0,
		ϵ₂ = 0.0, ω₁ = 1 + 0.015, ω₂ = 1 - 0.015) → ContinuousDynamicalSystem

A coupled 6D Rossler system from Krakovská et al. (2018).
The system consists of two separate subsystems, each being a 3D Rossler
attractor. The subsystems are bidirectionally coupled, influencing each other
through variables `x₁` and `x₂`.

The parameters and default values (if calling the keyword version of `rrbi`)
are as follows:

```
a = 0.1      # parameter in the Rössler attractor
b = 0.1      # parameter in the Rössler attractor
c = 14.0     # parameter in the Rössler attractor
ϵ₁ = 0.0     # influence of subsystem 1 on subsystem 2
ϵ₂ = 0.0     # influence of subsystem 2 on subsystem 1
ω₁ = 1+0.015 # the frequency of the first system
ω₂ = 1-0.015 # the frequency of the second system
```

The dynamics is generated by the vector field:

```math
\\begin{aligned}
dx₁ = ω₁*(-y₁) - z₁ + ϵ₂*(x₁ - x₂)
dy₁ = ω₁*x₁ + a*y₁
dz₁ = b + z₁*(x₁ - c)

dx₂ = ω₂*(-y₂) - z₂ + ϵ₁*(x₂ - x₁)
dy₂ = ω₂*x₂ + a*y₂
dz₂ = b + z₂*(x₂ - c)
\\end{aligned}
```

with the coupling constant ``c \\geq 0``.

# References
Krakovská, A., Jakubík, J., Chvosteková, M., Coufal, D., Jajcay, N., & Paluš, M. (2018). Comparison of six methods for the detection of causality in a bivariate time series. Physical Review E, 97(4), 042207.
"""
rossler_rossler(;u₀ = rand(6), a = 0.1, b = 0.1, c = 14.0,
            ϵ₁ = 0.0, ϵ₂ = 0.0, ω₁ = 1 + 0.015, ω₂ = 1 - 0.015) =
    rossler_rossler(u₀, a, b, c, ϵ₁, ϵ₂, ω₁, ω₂)

@inline @inbounds function eom_rossler_lorenz(u, p, t)
    c_xy, a₁, a₂, a₃, b₁, b₂, b₃ = (p...,)
    x1, x2, x3, y1, y2, y3 = u[1], u[2], u[3], u[4], u[5], u[6]

    dx1 = -a₁*(x2 + x3)
    dx2 = a₁*(x1 + a₂*x2)
    dx3 = a₁*(a₂ + x3*(x1 - a₃))
    dy1 = b₁*(-y1 + y2)
    dy2 = b₂*y1 - y2 - y1*y3 + c_xy*(x2^2)
    dy3 = y1*y2 - b₃*y3

    return SVector{6}(dx1, dx2, dx3, dy1, dy2, dy3)
end

"""
    rossler_lorenz(;u₀ = rand(6), a₁ = 6, a₂ = 6, a₃ = 2.0,
        b₁ = 10, b₂ = 28, b₃ = 8/3, c_xy = 1) → ContinuousDynamicalSystem

Initialise a Rössler-Lorenz system consisting of two independent 3D subsystems:
one Rössler system and one Lorenz system. They are coupled such that the
second component (`x₂`) of the Rössler system unidirectionally forces the
second component (`y₂`) of the Lorenz system.

The parameter `c_xy` controls the coupling strength. The implementation here also
allows for tuning the parameters of each subsystem by introducing the constants
`a₁`, `a₂`, `a₃`, `b₁`, `b₂`, `b₃`. Default values for these parameters are
as in [1].

## Equations of motion

The dynamics is generated by the following vector field

```math
\\begin{aligned}
\\dot x_1 &= -a_1(x_2 + x_3) \\\\
\\dot x_2 &= a_2(x_1 + a_2x_2) \\\\
\\dot x_3 &= a_1(a_2 + x_3(x_1 - a_3)) \\\\
\\dot y_1 &= b_1(y_2 - y_1) \\\\
\\dot y_2 &= y_1(b_2 - y_3) - y_2 +c_{xy}(x_2)^2 \\\\
\\dot y_3 &= y_1 y_2 - b_3y_3
\\end{aligned}
```

with the coupling constant ``c_{xy} \\geq 0``.

## References

1. Krakovská, Anna, et al. "Comparison of six methods for the detection of causality in a
    bivariate time series." Physical Review E 97.4 (2018):042207.
    [https://journals.aps.org/pre/abstract/10.1103/PhysRevE.97.042207](https://journals.aps.org/pre/abstract/10.1103/PhysRevE.97.042207)
"""
function rossler_lorenz(;u₀ = rand(6), a₁ = 6, a₂ = 0.2, a₃ = 5.7,
    b₁ = 10, b₂ = 28, b₃ = 8/3, c_xy = 1)
    @warn "`rossler_lorenz` is deprecated in CausalityTools v2. "*
    "Use `system(RosslerLorenzUnidir6())` instead, which returns a "*
    "`ContinuousDynamicalSystem` that can be iterated."

    p = @LArray [c_xy, a₁, a₂, a₃, b₁, b₂, b₃] (:c_xy, :a₁, :a₂, :a₃, :b₁, :b₂, :b₃)
    ContinuousDynamicalSystem(eom_rossler_lorenz, u₀, p)
end

@inline @inbounds function eom_lorenz_lorenz_bidir(u, p, t)
    c_xy, c_yx, a₁, a₂, a₃, b₁, b₂, b₃ = (p...,)
    x1, x2, x3, y1, y2, y3 = (u...,)

    dx1 = -a₁*(x1 - x2) + c_yx*(y1 - x1)
    dx2 = -x1*x3 + a₂*x1 - x2
    dx3 = x1*x2 - a₃*x3
    dy1 = -b₁*(y1 - y2) + c_xy*(x1 - y1)
    dy2 = -y1*y3 + b₂*y1 - y2
    dy3 = y1*y2 - b₃*y3

    return SVector{6}(dx1, dx2, dx3, dy1, dy2, dy3)
end

"""
    lorenz_lorenz_bidir(; u0 = rand(6),
        c_xy = 0.2, c_yx = 0.2,
        a₁ = 10, a₂ = 28, a₃ = 8/3,
        b₁ = 10, b₂ = 28, b₃ = 9/3) → ContinuousDynamicalSystem

Initialise a bidirectionally coupled Lorenz-Lorenz system, where each
subsystem is a 3D Lorenz system [1]. Default values for the parameters
`a₁`, `a₂`, `a₃`, `b₁`, `b₂`, `b₃` are as in [1].

## Equations of motion

The dynamics is generated by the following vector field

```math
\\begin{aligned}
\\dot{x_1} &= -a_1 (x_1 - x_2) + c_{yx}(y_1 - x_1) \\\\
\\dot{x_2} &= -x_1 x_3 + a_2 x_1 - x_2 \\\\
\\dot{x_3} &= x_1 x_2 - a_3 x_3 \\\\
\\dot{y_1} &= -b_1 (y_1 - y_2) + c_{xy} (x_1 - y_1) \\\\
\\dot{y_2} &= -y_1 y_3 + b_2 y_1 - y_2 \\\\
\\dot{y_3} &= y_1 y_2 - b_3 y_3
\\end{aligned}
```

## References

1. Amigó, José M., and Yoshito Hirata. "Detecting directional couplings from
    multivariate flows by the joint distance distribution." Chaos: An
    Interdisciplinary Journal of Nonlinear Science 28.7 (2018): 075302.
"""
function lorenz_lorenz_bidir(; u0 = rand(6),
        c_xy = 0.2, c_yx = 0.2,
        a₁ = 10, a₂ = 28, a₃ = 8/3,
        b₁ = 10, b₂ = 28, b₃ = 9/3)
    @warn "`lorenz_lorenz_bidir` is deprecated in CausalityTools v2. "*
    "Use `system(LorenzBidir6())` instead, which returns a "*
    "`ContinuousDynamicalSystem` that can be iterated."
    p = @LArray [c_xy, c_yx, a₁, a₂, a₃, b₁, b₂, b₃] (:c_xy, :c_yx, :a₁, :a₂, :a₃, :b₁, :b₂, :b₃)
    ContinuousDynamicalSystem(eom_lorenz_lorenz_bidir, u0, p)
end

function lorenzlorenz_bidir_trajectory(npts; sample_dt = 1, Ttr = 1000, dt = 0.1,
    c_xy = 0.1, c_yx = 0.1,
    u0 = rand(6),
    a₁ = 10, a₂ = 28, a₃ = 8/3,
    b₁ = 10, b₂ = 28, b₃ = 9/3)
    @warn "`lorenzlorenz_bidir_trajectory` is deprecated in CausalityTools v2. "
    s = lorenz_lorenz_bidir(u0 = u0, c_xy = c_xy, c_yx = c_yx, a₁ = a₁, a₂ = a₂, a₃ = a₃, b₁ = b₁, b₂ = b₂, b₃ = b₃)

    # the system is recorded at times t0:dt:T
    T = npts*dt*sample_dt

    o = trajectory(s, T, dt = dt, Ttr = Ttr*dt, alg = SimpleATsit5())[1:sample_dt:end-1, :]
end

# For some initial conditions, the system wanders off and doesn't settle to an attractor. Create a function that loops until we get a good realization.
function good_lorenzlorenz_bidir_trajectory(npts;
        sample_dt = 1,
        dt = 0.1,
        c_xy = 0.1,
        c_yx = 0.1,
        Da₁ = Uniform(9.5, 10.5),
        Da₂ = Uniform(27, 29),
        Da₃ = Uniform(7.5/3, 8.5/3),
        Db₁ = Uniform(9.5, 10.5),
        Db₂ = Uniform(27, 29),
        Db₃ = Uniform(7.5/3, 8.5/3),
        a₁ = nothing,
        a₂ = nothing,
        a₃ = nothing,
        b₁ = nothing,
        b₂ = nothing,
        b₃ = nothing,
        u0 = rand(6),
        Ttr = 10000,
        n_maxtries = 300)

    n_tries = 0
    while n_tries <= n_maxtries
        a₁ == nothing ? a₁ = rand(Da₁) : nothing
        a₂ == nothing ? a₂ = rand(Da₂) : nothing
        a₃ == nothing ? a₃ = rand(Da₃) : nothing
        b₁ == nothing ? b₁ = rand(Db₁) : nothing
        b₂ == nothing ? b₂ = rand(Db₂) : nothing
        b₃ == nothing ? b₃ = rand(Db₃) : nothing

        pts = lorenzlorenz_bidir_trajectory(npts,
            sample_dt = sample_dt, dt = dt,
            c_xy = c_xy, c_yx = c_yx,
            Ttr = Ttr)

        M = Matrix(pts)

        if all(isfinite.(M)) && all(M .< 1e10) && count(M .≈ 0) < npts*0.1 && count(abs.(M) .< 1e-10) < npts*0.1 &&
            (count(abs.(M) .< 1e-12) < npts*0.1)
            return pts
        end
        println("no attractor found. trying with new initial condition and parameters")
        n_tries += 1
    end
end

function eom_chuacircuits_driven(u, p, t)
    α₁, α₂, β₁, β₂, F₁, F₂, ω₁, ω₂, ϵ₁, ϵ₂, m₀, m₁, σ = (p...,)
    x₁, y₁, z₁ = (u[1:3]...,)
    x₂, y₂, z₂ = (u[4:6]...,)

    # Dynamical noise
    if σ == 0
        ξ = 0
    else
        ξ = rand(Normal(0, σ))
    end

    hx₁ = m₁*x₁ + 0.5*(m₀ - m₁)*(abs(x₁+1) - abs(x₁-1))
    hx₂ = m₁*x₂ + 0.5*(m₀ - m₁)*(abs(x₂+1) - abs(x₂-1))

    dx₁ = α₁*(y₁-hx₁) - α₁*ϵ₂*(x₁ - x₂)
    dy₁ = x₁-y₁+z₁
    dz₁ = -β₁*y₁ + F₁*sin(ω₁*t) + ξ

    dx₂ = α₂*(y₂-hx₂) - α₂*ϵ₁*(x₁ - x₂)
    dy₂ = x₂-y₂+z₂
    dz₂ = -β₂*y₂ + F₂*sin(ω₂*t) + ξ
    SVector{6}(dx₁, dy₁, dz₁, dx₂, dy₂, dz₂)
end

function chuacircuits_driven(u₀, α₁, α₂, β₁, β₂, F₁, F₂,
                                      ω₁, ω₂, ϵ₁, ϵ₂, m₀, m₁, σ)
    @warn "`chuacircuits_driven` is deprecated in CausalityTools v2. "*
    "Use `system(ChuaCircuitsBidir6())` instead, which returns a "*
    "`ContinuousDynamicalSystem` that can be iterated."
    p = @LArray [α₁, α₂, β₁, β₂, F₁, F₂, ω₁, ω₂, ϵ₁, ϵ₂, m₀, m₁, σ] (:α₁, :α₂, :β₁, :β₂, :F₁, :F₂, :ω₁, :ω₂, :ϵ₁, :ϵ₂, :m₀, :m₁, :σ)
    ContinuousDynamicalSystem(eom_chuacircuits_driven, u₀, p)
end

"""
    chuacircuits_driven(;u₀ = [0.1, 0.1, 0.2, 0.15, 0.15, 0.22],
        α₁ = 7.0, α₂ = 7.0, β₁ = 14.286, β₂ = 14.286,
        F₁ = 1.5, F₂ = 1.5, ω₁ = 3.0, ω₂ = 3.0,
        σ = 0.1, ϵ₁ = 0.1, ϵ₂ = 0.1, m₀ = -1/7, m₁ = 2/7) → ContinuousDynamicalSystem

Initialize a bidirectionally coupled system consisting of two driven Chua
circuits [1], X₁ and X₂. The subsystems are mutually coupled by a linear
resistor, where `ϵ₁` controls the influence of X₁ on X₂, and `ϵ₂` controls the
influence of X₂ on X₁. The parameters for the subsystems are
set equal to each other, as in the original paper, but can be tuned
individually for each subsystem.

## References

1. Murali, K., and M. Lakshmanan. "Chaotic dynamics of the driven Chua's
    circuit." IEEE Transactions on Circuits and Systems I Fundamental
    Theory and Applications 40.11 (1993): 836-840.
"""
chuacircuits_driven(;u₀ = [0.1, 0.1, 0.2, 0.15, 0.15, 0.22],
                            α₁ = 7.0, α₂ = 7.0,
                            β₁ = 14.286, β₂ = 14.286,
                            F₁ = 1.5, F₂ = 1.5,
                            ω₁ = 3.0, ω₂ = 3.0,
                            σ = 0.1,
                            ϵ₁ = 0.1, ϵ₂ = 0.1,
                            m₀ = -1/7, m₁ = 2/7) =
    chuacircuits_driven(u₀, α₁, α₂, β₁, β₂, F₁, F₂, ω₁, ω₂, ϵ₁, ϵ₂, m₀, m₁, σ)



@inline @inbounds function eom_lorenztriple_forced(u, p, t)
    c_xy, c_yx, c_zx, c_zy, a₁, a₂, a₃, b₁, b₂, b₃, a₃, c₁, c₂, c₃ = (p...,)
    x₁, x₂, x₃, y₁, y₂, y₃, z₁, z₂, z₃ = (u...,)

    dx₁ = -a₁*(x₁ - x₂) + c_yx*(y₁ - x₁) + c_zx*(z₁ - x₁)
    dx₂ = -x₁*x₃ + a₂*x₁ - x₂
    dx₃ = x₁*x₂ - a₃*x₃

    dy₁ = -b₁*(y₁ - y₂) + c_xy*(x₁ - y₁) + c_zy*(z₁ - y₁)
    dy₂ = -y₁*y₃ + b₂*y₁ - y₂
    dy₃ = y₁*y₂ - b₃*y₃

    dz₁ = -c₁*(z₁ - z₂)
    dz₂ = -z₁*z₃ + c₂*z₁ - z₂
    dz₃ = z₁*z₂ - c₃*z₃

    return SVector{9}(dx₁, dx₂, dx₃, dy₁, dy₁, dy₃, dz₁, dz₂, dz₃)
end

"""
    lorenz_lorenz_lorenz_bidir_forced(; u0 = rand(9),
        c_xy = 0.1, c_yx = 0.1,
        c_zx = 0.05, c_zy = 0.05,
        a₁ = 10, a₂ = 28, a₃ = 8/3,
        b₁ = 10, b₂ = 28, b₃ = 8/3,
        c₁ = 10, c₂ = 28, c₃ = 8/3)

Initialise a system consisting of two bidirectionally coupled 3D Lorenz
systems forced by an external 3D Lorenz system, giving a 9D system.

## Equations of motion

The dynamics is generated by the following vector field

```math
\\begin{aligned}
\\dot{x_1} &= - a_1 (x_1 - x_2) + c_{yx}(y_1 - x_1) + c_{zx}(z_1 - x_1) \\\\
\\dot{x_2} &= - x_1 x_3 + a_2 x_1 - x_2 \\\\
\\dot{x_3} &= x_1 x_2 - a_3 x_3 \\\\
\\dot{y_1} &= -b_1 (y_1 - y_2) + c_{xy} (x_1 - y_1) + c_{zy}(z_1 - y_1) \\\\
\\dot{y_2} &= - y_1 y_3 + b_2 y_1 - y_2 \\\\
\\dot{y_3} &= y_1 y_2 - b_3 y_3 \\\\
\\dot{z_1} &= - c_1 (z_1 - z_2) \\\\
\\dot{z_2} &= - z_1 z_3 + c_2 z_1 - z_2 \\\\
\\dot{z_3} &= z_1 z_2 - c_3 z_3
\\end{aligned}
```

## References

1. Amigó, José M., and Yoshito Hirata. "Detecting directional couplings from
    multivariate flows by the joint distance distribution." Chaos: An
    Interdisciplinary Journal of Nonlinear Science 28.7 (2018): 075302.
"""
function lorenz_lorenz_lorenz_bidir_forced(; u0 = rand(9),
        c_xy = 0.1, c_yx = 0.1,
        c_zx = 0.05, c_zy = 0.05,
        a₁ = 10, a₂ = 28, a₃ = 8/3,
        b₁ = 10, b₂ = 28, b₃ = 8/3,
        c₁ = 10, c₂ = 28, c₃ = 8/3)
    @warn "`lorenz_lorenz_lorenz_bidir_forced` is deprecated in CausalityTools v2. "*
    "Use `system(LorenzForced9())` instead, which returns a "*
    "`ContinuousDynamicalSystem` that can be iterated."

    p = @LArray [c_xy, c_yx, c_zx, c_zy, a₁, a₂, a₃, b₁, b₂, b₃, a₃, c₁, c₂, c₃] (:c_xy, :c_yx, :c_zx, :c_zy, :a₁, :a₂, :a₃, :b₁, :b₂, :b₃, :a₃, :c₁, :c₂, :c₃)
    ContinuousDynamicalSystem(eom_lorenz_lorenz_lorenz_bidir_forced, u0, p)
end

function lorenz_lorenz_lorenz_bidir_forced_trajectory(npts;
        n_transient = 2000, dt = 0.1, sample_dt = 1,
        u0 = rand(9),
        c_xy = 1.0, c_yx = 1.0, c_zx = 1.0, c_zy = 1.0, # beyond c = 2, systems syncronize
        a₁ = 10, a₂ = 28, a₃ = 8/3,
        b₁ = 10, b₂ = 28, b₃ = 8/3,
        c₁ = 10, c₂ = 28, c₃ = 8/3)
    @warn "`lorenz_lorenz_lorenz_bidir_forced_trajectory` is deprecated in CausalityTools v2."
    s = lorenz_lorenz_lorenz_bidir_forced(u0 = u0,
        c_xy = c_xy, c_yx = c_yx,
        c_zx = c_zx, c_zy = c_zy,
        a₁ = a₁, a₂ = a₂, a₃ = a₃,
        b₁ = b₁, b₂ = b₂, b₃ = b₃,
        c₁ = c₁, c₂ = c₂, c₃ = c₃)

    # the system is recorded at times t0:dt:T
    T = npts*dt*sample_dt
    o = trajectory(s, T, Δt = dt, Ttr = n_transient*dt,
        alg = SimpleDiffEq.SimpleATsit5())[1:sample_dt:end-1, :] #alg = SimpleDiffEq.SimpleATsit5()
end

function good_lorenz_lorenz_lorenz_bidir_forced_trajectory(npts;
        sample_dt = 1,  Ttr = 5000, dt = 0.1,
        Da₁ = Uniform(9.5, 10.5),
        Da₂ = Uniform(27.5, 28.5),
        Da₃ = Uniform(7.5/3, 8.5/3),
        Db₁ = Uniform(9.5, 10.5),
        Db₂ = Uniform(27.5, 28.5),
        Db₃ = Uniform(7.5/3, 8.5/3),
        Dc₁ = Uniform(9.5, 10.5),
        Dc₂ = Uniform(27.5, 28.5),
        Dc₃ = Uniform(7.5/3, 8.5/3),

        a₁ = nothing,
        a₂ = nothing,
        a₃ = nothing,
        b₁ = nothing,
        b₂ = nothing,
        b₃ = nothing,
        c₁ = nothing,
        c₂ = nothing,
        c₃ = nothing,
        c_xy = 0.2,  c_yx = 0.2,
        c_zx = 0.05, c_zy = 0.05,
        u0 = [rand(Uniform(0, 10)) for i = 1:9],
        n_maxtries = 300)

    n_tries = 0

    while n_tries <= n_maxtries
        a₁ == nothing ? a₁ = rand(Da₁) : a₁ = a₁
        a₂ == nothing ? a₂ = rand(Da₂) : a₂ = a₂
        a₃ == nothing ? a₃ = rand(Da₃) : a₃ = a₃
        b₁ == nothing ? b₁ = rand(Db₁) : b₁ = b₁
        b₂ == nothing ? b₂ = rand(Db₂) : b₂ = b₂
        b₃ == nothing ? b₃ = rand(Db₃) : b₃ = b₃
        c₁ == nothing ? c₁ = rand(Dc₁) : c₁ = c₁
        c₂ == nothing ? c₂ = rand(Dc₂) : c₂ = c₂
        c₃ == nothing ? c₃ = rand(Dc₃) : c₃ = c₃
        pts = lorenz_lorenz_lorenz_bidir_forced(npts,
            sample_dt = sample_dt, dt = dt, n_transient = Ttr,
            c_xy = c_xy,  c_yx = c_yx,
            c_zx = c_zx, c_zy = c_zy,
            a₁ = a₁, a₂ = a₂, a₃ = a₃,
            b₁ = b₁, b₂ = b₂, b₃ = b₃,
            c₁ = c₁, c₂ = c₂, c₃ = c₃)



        if all(Matrix(pts) .< 1e9) #&& length(unique(pts)) < length(pts)*0.8
            return pts
        end
        println("no attractor found. trying with new initial condition and parameters")
        n_tries += 1
    end
end

@inline @inbounds function eom_lorenz_lorenz_lorenz_transitive(u, p, t)
    x₁, y₁, z₁, x₂, y₂, z₂, x₃, y₃, z₃ = (u...,)
    σ₁, σ₂, σ₃, ρ₁, ρ₂, ρ₃, β₁, β₂, β₃, c₁₂, c₂₃ = (p...,)

    # Subsystem 1
    dx₁ = σ₁*(y₁-x₁)
    dy₁ = ρ₁*x₁ - y₁ - x₁*z₁
    dz₁ = x₁*y₁ - β₁*z₁

    # Subsystem 2
    dx₂ = σ₂*(y₂-x₂) + c₁₂*(x₁ - x₂)
    dy₂ = ρ₂*x₂ - y₂ - x₂*z₂
    dz₂ = x₂*y₂ - β₂*z₂

    # Subsystem 3
    dx₃ = σ₃*(y₃-x₃) + c₂₃*(x₂ - x₃)
    dy₃ = ρ₃*x₃ - y₃ - x₃*z₃
    dz₃ = x₃*y₃ - β₃*z₃
    return SVector{9}(dx₁, dy₁, dz₁, dx₂, dy₂,dz₂, dx₃, dy₃, dz₃)
end

function lorenz_lorenz_lorenz_transitive(u₀, σ₁, σ₂, σ₃, ρ₁, ρ₂, ρ₃, β₁, β₂, β₃, c₁₂, c₂₃)
    p = @LArray [σ₁, σ₂, σ₃, ρ₁, ρ₂, ρ₃, β₁, β₂, β₃, c₁₂, c₂₃] (:σ₁, :σ₂, :σ₃, :ρ₁, :ρ₂, :ρ₃, :β₁, :β₂, :β₃, :c₁₂, :c₂₃)
    ContinuousDynamicalSystem(eom_lorenz_lorenz_lorenz_transitive, u₀, p)
end

"""
    lorenz_lorenz_lorenz_transitive(;u₀=rand(9),
                σ₁ = 10.0, σ₂ = 10.0, σ₃ = 10.0,
                ρ₁ = 28.0, ρ₂ = 28.0, ρ₃ = 28.0,
                β₁ = 8/3,  β₂ = 8/3,  β₃ = 8.3,
                c₁₂ = 1.0, c₂₃ = 1.0) → ContinuousDynamicalSystem

Initalise a dynamical system consisting of three coupled Lorenz attractors with
a transitive causality chain where X₁ → X₂ and X₂ → X₃. In total, the three
3D-subsystems create a 9-dimensional dynamical system.

The strength of the forcing X₁ → X₂ is controlled by the parameter `c₁`, and
the forcing from X₂ → X₃ by `c₂`. The remaining parameters are the usual
parameters for the Lorenz system, where the subscript `i` refers to the
subsystem Xᵢ.

## Equations of motion

The dynamics is generated by the following vector field

```math
\\begin{aligned}
\\dot{x_1} &= \\sigma_1(y_1 - x_1) \\\\
\\dot{y_1} &= \\rho_1 x_1 - y_1 - x_1 z_1 \\\\
\\dot{z_1} &= x_1 y_1 - \\beta_1 z_1 \\\\
\\dot{x_2} &=  \\sigma_2 (y_2 - x_2) + c_{12}(x_1 - x_2) \\\\
\\dot{y_2} &= \\rho_2 x_2 - y_2 - x_2 z_2 \\\\
\\dot{z_2} &= x_2 y_2 - \\beta_2 z_2 \\\\
\\dot{x_3} &= \\sigma_3 (y_3 - x_3) + c_{23} (x_2 - x_3) \\\\
\\dot{y_3} &= \\rho_3 x_3 - y_3 - x_3 z_3 \\\\
\\dot{z_3} &= x_3 y_3 - \\beta_3 z_3
\\end{aligned}
```

## Usage in literature

This system was studied by Papana et al. (2013) for coupling strengths
``c_{12} = 0, 1, 3, 5`` and ``c_{23} = 0, 1, 3, 5``.

## References

1. Papana et al., Simulation Study of Direct Causality Measures in Multivariate
    Time Series. Entropy 2013, 15(7), 2635-2661; doi:10.3390/e15072635
"""
lorenz_lorenz_lorenz_transitive(;u₀=rand(9),
            σ₁ = 10.0, σ₂ = 10.0, σ₃ = 10.0,
            ρ₁ = 28.0, ρ₂ = 28.0, ρ₃ = 28.0,
            β₁ = 8/3,  β₂ = 8/3,  β₃ = 8.3,
            c₁₂ = 1.0, c₂₃ = 1.0) =
    lorenz_lorenz_lorenz_transitive(u₀, σ₁, σ₂, σ₃, ρ₁, ρ₂, ρ₃, β₁, β₂, β₃, c₁₂, c₂₃)


@inline @inbounds function eom_rossler_rossler_rossler_bidir_forced(u, p, t)
    ω₁, ω₂, ω₃, c_xy, c_yx, c_zx, c_zy, a₁, a₂, a₃, b₁, b₂, b₃, a₃, c₁, c₂, c₃ = (p...,)
    x1, x2, x3, y1, y2, y3, z1, z2, z3 = (u...,)

    dx1 = -ω₁*(x2 + x3) + c_yx*(y1 - x1) + c_zx*(z1 - x1)
    dx2 = ω₁*x1 + a₁*x2
    dx3 = a₂ + x3*(x1 - a₃)

    dy1 = -ω₂*(y2 + y3) + c_xy*(x1 - y1) + c_zy*(z1 - y1)
    dy2 = ω₂*y1 + b₁*y2
    dy3 = b₂ + y3*(y1 - b₃)

    dz1 = -ω₂*(z2 + z3)
    dz2 = ω₂*z1 + c₁*z2
    dz3 = c₂ + z3*(z1 - c₃)

    return SVector{9}(dx1, dx2, dx3, dy1, dy2, dy3, dz1, dz2, dz3)
end

"""
    rossler_rossler_rossler_bidir_forced(; u0 = rand(9),
        ω₁ = 1.015, ω₂ = 0.985, ω₃ = 0.95,
        c_xy = 0.1, c_yx = 0.1,
        c_zx = 0.05, c_zy = 0.05,
        a₁ = 0.15, a₂ = 0.2, a₃ = 10,
        b₁ = 0.15, b₂ = 0.2, b₃ = 10,
        c₁ = 0.15, c₂ = 0.2, c₃ = 10)

Equations of motion for a system consisting of three coupled 3D Rössler systems
(``X``, ``Y``, ``Z``), giving a 9D system [1]. The external system
``Z`` influences both ``X`` and ``Y`` (controlled by `c_zx` and `c_zy`).
Simultaneously, the subsystems  ``X`` and ``Y`` bidirectionally
influences each other (controlled by `c_xy` and `c_yx`).

The ``X`` and ``Y`` subsystems are mostly synchronized for `c_xy > 0.1` or
`c_yx > 0.1`.

## Equations of motion

The dynamics is generated by the following vector field

```math
\\begin{aligned}
\\dot{x_1} &= -\\omega_1 (x_2 + x_3) + c_{yx}(y_1 - x_1) + c_{zx}(z_1 - x_1) \\\\
\\dot{x_2} &= \\omega_1 x_1 + a_1 x_2 \\\\
\\dot{x_3} &= a_2 + x_3 (x_1 - a_3) \\\\
\\dot{y_1} &= -\\omega_1 (y_2 + y_3) + c_{xy}(x_1 - y_1) + c_{zy}(z_1 - y_1) \\\\
\\dot{x_2} &= \\omega_2 y_1 + b_1 y_2 \\\\
\\dot{x_3} &= b_2 + x_3 (y_1 - b_3) \\\\
\\dot{y_1} &= -\\omega_2 (z_2  + z_3) \\\\
\\dot{x_2} &= \\omega_2 z_1 + c_1 z_2 \\\\
\\dot{x_3} &= c_2 + z_3 (z_1 - c_3)
\\end{aligned}
```

## References

1. Amigó, José M., and Yoshito Hirata. "Detecting directional couplings from
    multivariate flows by the joint distance distribution." Chaos: An
    Interdisciplinary Journal of Nonlinear Science 28.7 (2018): 075302.
"""
function rossler_rossler_rossler_bidir_forced(; u0 = rand(9),
        ω₁ = 1.015, ω₂ = 0.985, ω₃ = 0.95,
        c_xy = 0.1, c_yx = 0.1,
        c_zx = 0.05, c_zy = 0.05,
        a₁ = 0.15, a₂ = 0.2, a₃ = 10,
        b₁ = 0.15, b₂ = 0.2, b₃ = 10,
        c₁ = 0.15, c₂ = 0.2, c₃ = 10)
    @warn "`rossler_rossler_rossler_bidir_forced` is deprecated in CausalityTools v2. "*
    "Use `system(RosslerForced9())` instead, which returns a "*
    "`ContinuousDynamicalSystem` that can be iterated."

    p = @LArray [ω₁, ω₂, ω₃, c_xy, c_yx, c_zx, c_zy, a₁, a₂, a₃, b₁, b₂, b₃, a₃, c₁, c₂, c₃] (:ω₁, :ω₂, :ω₃, :c_xy, :c_yx, :c_zx, :c_zy, :a₁, :a₂, :a₃, :b₁, :b₂, :b₃, :a₃, :c₁, :c₂, :c₃)
    ContinuousDynamicalSystem(eom_rossler_rossler_rossler_bidir_forced, u0, p)
end

function forced_rossler_rossler_bidir_trajectory(npts;
        n_transient = 2000, dt = 0.6, sample_dt = 1,
        u0 = rand(9), ω₁ = 1.015, ω₂ = 0.985, ω₃ = 0.95,
        c_xy = 0.2, c_yx = 0.2, c_zx = 0.05, c_zy = 0.05,
        a₁ = 0.15, a₂ = 0.2, a₃ = 10,
        b₁ = 0.15, b₂ = 0.2, b₃ = 10,
        c₁ = 0.15, c₂ = 0.2, c₃ = 10)
    @warn "`forced_rossler_rossler_bidir_trajectory` is deprecated in CausalityTools v2."

    s = rossler_rossler_rossler_bidir_forced(u0 = u0,
        c_xy = c_xy, c_yx = c_yx,
        c_zx = c_zx, c_zy = c_zy,
        ω₁ = ω₁, ω₂ = ω₂, ω₃ = ω₃,
        a₁ = a₁, a₂ = a₂, a₃ = a₃,
        b₁ = b₁, b₂ = b₂, b₃ = b₃,
        c₁ = c₁, c₂ = c₂, c₃ = c₃)

    # the system is recorded at times t0:dt:T
    T = npts*dt*sample_dt
    o = trajectory(s, T, dt = dt, Ttr = n_transient*dt, alg = SimpleDiffEq.SimpleATsit5())[1:sample_dt:end-1, :] #alg = SimpleDiffEq.SimpleATsit5()
end

function good_rossler_rossler_rossler_bidir_forced_trajectory(npts;
        sample_dt = 1,  Ttr = 5000, dt = 0.3, # dt = 0.6 about 10 samples per period
        Da₁ = Uniform(0.12, 0.17),
        Da₂ = Uniform(0.18, 0.22),
        Da₃ = Uniform(9.0, 11.0),
        Db₁ = Uniform(0.10, 0.20),
        Db₂ = Uniform(0.18, 0.22),
        Db₃ = Uniform(9.0, 11.0),
        Dc₁ = Uniform(0.10, 0.20),
        Dc₂ = Uniform(0.18, 0.22),
        Dc₃ = Uniform(9.0, 11.0),
        Dω₁ = Uniform(0.95, 0.999), #Uniform(0.97, 1.03)
        Dω₂ = Uniform(1.001, 1.05), #Uniform(0.97, 1.03)
        Dω₃ = Uniform(0.9, 0.95), #Uniform(0.97, 1.03)

        a₁ = nothing,
        a₂ = nothing,
        a₃ = nothing,
        b₁ = nothing,
        b₂ = nothing,
        b₃ = nothing,
        c₁ = nothing,
        c₂ = nothing,
        c₃ = nothing,
        ω₁ = nothing,
        ω₂ = nothing,
        ω₃ = nothing,
        c_xy = 0.2,  c_yx = 0.2,
        c_zx = 0.05, c_zy = 0.05,
        u0 = rand(9),
        n_maxtries = 300)

    n_tries = 0

    while n_tries <= n_maxtries
        ω₁ == nothing ? ω₁ = rand(Dω₁) : ω₁ = ω₁
        ω₂ == nothing ? ω₂ = rand(Dω₂) : ω₂ = ω₂
        ω₃ == nothing ? ω₃ = rand(Dω₃) : ω₃ = ω₃
        a₁ == nothing ? a₁ = rand(Da₁) : a₁ = a₁
        a₂ == nothing ? a₂ = rand(Da₂) : a₂ = a₂
        a₃ == nothing ? a₃ = rand(Da₃) : a₃ = a₃
        b₁ == nothing ? b₁ = rand(Db₁) : b₁ = b₁
        b₂ == nothing ? b₂ = rand(Db₂) : b₂ = b₂
        b₃ == nothing ? b₃ = rand(Db₃) : b₃ = b₃
        c₁ == nothing ? c₁ = rand(Dc₁) : c₁ = c₁
        c₂ == nothing ? c₂ = rand(Dc₂) : c₂ = c₂
        c₃ == nothing ? c₃ = rand(Dc₃) : c₃ = c₃
        pts = rossler_rossler_rossler_bidir_forced(npts,
            sample_dt = sample_dt, dt = dt, n_transient = Ttr,
            c_xy = c_xy,  c_yx = c_yx,
            c_zx = c_zx, c_zy = c_zy,
            ω₁ = ω₁, ω₂ = ω₂, ω₃ = ω₃,
            a₁ = a₁, a₂ = a₂, a₃ = a₃,
            b₁ = b₁, b₂ = b₂, b₃ = b₃,
            c₁ = c₁, c₂ = c₂, c₃ = c₃)

        if all(Matrix(pts) .< 1e10) && length(unique(pts)) > npts/2
            return pts
        end
        println("no attractor found. trying with new initial condition and parameters")
        n_tries += 1
    end
end

@inline @inbounds function eom_mediated_link(u, p, t)
    (; xi, ωx, ωy, ωz, k, l, m, c) = p
    x₁, x₂, x₃, y₁, y₂, y₃, z₁, z₂, z₃ = u

    dx₁ = -ωx*x₂ - x₃ + c*(z₁ - x₁)
	dx₂ = ωx*x₁ + k*x₂
	dx₃ = l + x₃*(x₁ - m)

	dy₁ = -ωy*y₂ - y₃ + c*(z₁ - y₁)
	dy₂ = ωy*y₁ + k*y₂
	dy₃ = l + y₃*(y₁ - m)

	dz₁ = -ωz*z₂ - z₃
	dz₂ = ωz*z₁ + k*z₂
	dz₃ = l + z₃*(z₁ - m)

    SVector{9}(dx₁, dx₂, dx₃, dy₁, dy₂, dy₃, dz₁, dz₂, dz₃)
end

function mediated_link(u₀, ωx, ωy, ωz, k, l, m, c)
    @warn "`mediated_link` is deprecated in CausalityTools v2. "*
    "Use `system(MediatedLink9())` instead, which returns a "*
    "`ContinuousDynamicalSystem` that can be iterated."
    p = @LArray [ωx, ωy, ωz, k, l, m, c] (:ωx, :ωy, :ωz, :k, :l, :m, :c)
    ContinuousDynamicalSystem(eom_mediated_link, u₀, p)
end

"""
    mediated_link(;u₀ = rand(9), ωx = 1, ωy = 1.015, ωz = 0.985,
        k = 0.15, l = 0.2, m = 10.0,
        c = 0.06) → ContinuousDynamicalSystem

Initialise a three-subsystem dynamical system where `X` and `Y` are
driven by `Z`. At the default value of the coupling constant `c = 0.06`, the
responses `X` and `Y` are already synchronized to the driver `Z`.

## Equations of motion

The dynamics is generated by the following vector field

```math
\\begin{aligned}
dx_1 &= -\\omega_x x_2 - x_3 + c*(z_1 - x_1) \\\\
dx_2 &= \\omega_x x_1 + k*x_2  \\\\
dx_3 &= l + x_3(x_1 - m)  \\\\
dy_1 &= -\\omega_y y_2 - y_3 + c*(z_1 - y_1)  \\\\
dy_2 &= \\omega_y y_1 + k*y_2  \\\\
dy_3 &= l + y_3(y_1 - m)  \\\\
dz_1 &= -\\omega_z z_2 - z_3  \\\\
dz_2 &= \\omega_z z_1 + k*z_2  \\\\
dz_3 &= l + z_3(z_1 - m)
\\end{aligned}
```

##  References

1. Krakovská, Anna, et al. "Comparison of six methods for the detection of
    causality in a bivariate time series." Physical Review E 97.4 (2018): 042207
"""
mediated_link(;u₀ = rand(9), ωx = 1, ωy = 1.015, ωz = 0.985,
            k = 0.15, l = 0.2, m = 10.0, c = 0.06) =
    mediated_link(u₀, ωx, ωy, ωz, k, l, m, c)


@inline @inbounds function eom_repressilator(u, p, t)
    (; xi, α, α₀, n, β) = p
    # pᵢ := concentration of protein repressor i
    # mᵢ := concentration of mRNA associated with pᵢ
    m₁, m₂, m₃, p₁, p₂, p₃ = u

    ṁ₁ = -m₁ + α/(1 + p₃^n) + α₀
    ṁ₂ = -m₂ + α/(1 + p₁^n) + α₀
    ṁ₃ = -m₃ + α/(1 + p₂^n) + α₀
    ṗ₁ = -β*(p₁ - m₁)
    ṗ₂ = -β*(p₂ - m₂)
    ṗ₃ = -β*(p₃ - m₃)

    return SVector{6}(ṁ₁, ṁ₂, ṁ₃, ṗ₁, ṗ₂, ṗ₃)
end

"""
    repressilator(;u₀ = rand(6), α = 10.0, α₀ = 0.0, β = 100.0,
        n = 2) → ContinuousDynamicalSystem

A six-dimensional repressilator (or repression-driven oscillator) from Elowitz & Leibler
(2000)[^Elowitz2000]. The equations are scaled to be non-dimensional.

Used in Sun & Bollt (2014) to study the performance of the causation entropy algorithm.

[^Elowitz2000]: Elowitz, M. B., & Leibler, S. (2000). A synthetic oscillatory network of
    transcriptional regulators. Nature, 403(6767), 335-338.
[^Sun2014]: Sun, J., Cafaro, C., & Bollt, E. M. (2014). Identifying the coupling structure
    in complex systems through the optimal causation entropy principle. Entropy, 16(6),
    3416-3433.
"""
function repressilator(;u₀ = rand(6), α = 10.0, α₀ = 0.0, β = 100.0, n = 2)
    @warn "`repressilator` is deprecated in CausalityTools v2. "*
    "Use `system(Repressilator6())` instead, which returns a "*
    "`ContinuousDynamicalSystem` that can be iterated."
    p = @LArray [α, α₀, β, n] (:α, :α₀, :β, :n)
    ContinuousDynamicalSystem(eom_repressilator, u₀, p)
end


function eom_hindmarsh_rose(u, p, t)
    a, b, c, d, r, s, xᵣ, I = (p...,)
    x, y, z = u

	ϕ = -a*x^3 + b*x^2
	ψ = c - d*x^2
    dx = y + ϕ - z + I
	dy = ψ - y
	dz = r*(s*(x - xᵣ) - z)
    return SVector{3}(dx, dy, dz)
end

"""
	hindmarsh_rose(u₀, p)

Initialise a Hindmarsh-Rose system, which is a model of neuronal
spiking.

```math
\\begin{aligned}
\\dfrac{dx}{dt} &= y + \\phi(x) - z + I
\\dfrac{dy}{dt} &= \\psi(x) - y
\\dfrac{dz}{dt} &= r[s(x - x_R) - z],
\\end{aligned}
```
where

```math
\\begin{aligned}
\\phi(x) &= -ax^3+bx^2
\\psi(x) &= c - dx^2
\\end{aligned}
```

If parameters other than the defaults are to be used, they must be
provided as a vector `[a, b, c, d, r, s, xᵣ, I]`.
"""
function hindmarsh_rose(u₀, p)
    @warn "`hindmarsh_rose` is deprecated in CausalityTools v2. "*
    "Use `system(HindmarshRose3())` instead, which returns a "*
    "`ContinuousDynamicalSystem` that can be iterated."
    ContinuousDynamicalSystem(eom_hindmarsh_rose, u₀, p)
end
hindmarsh_rose(;u₀ = rand(3), a = 1, b = 3, c = 1, d = 5, r = 1e-3, s = 4, xᵣ = - 8/5, I = -8) =
    hindmarsh_rose(u₀, [a, b, c, d, r, s, xᵣ, I])

@inline @inbounds function eom_lorenzdiffusive(u, p, t)

    C₁₂, C₂₁, R, ϵ₁, ϵ₂ = p[1], p[2], p[3], p[4], p[5]
    x₁, x₂, x₃ = u[1], u[2], u[3]
    y₁, y₂, y₃ = u[4], u[5], u[6]

    dx1 = 10*(x₂ - x₁) + C₂₁*(y₁-x₁)
    dx2 = x₁*((R+ϵ₁) - x₃) - x₂
    dx3 = x₁*x₂ - 8/3*x₃

    dy1 = 10*(y₂ - y₁) + C₁₂*(x₁-y₁)
    dy2 = y₁*((R+ϵ₂) - y₃) - y₂
    dy3 = y₁*y₂ - 8/3*y₃
    return SVector{6}(dx1, dx2, dx3, dy1, dy2, dy3)
end

"""
    lorenzdiffusive(; ui = rand(6), C₁₂::Real = 5, C₂₁::Real = 0,
        R::Real = 28.0, ϵ₁::Real = -0.02, ϵ₂::Real = 0.03)

A dynamical system consisting of two diffusively coupled 3D Lorenz systems[^Martini2011].

The coupling magnitude from subsystem 1 to subsystem 2 is controlled by `C₁₂`, and the
coupling from subsystem 2 to subsystem 1 is controlled by `C₂₁`. The parameters `ϵ₁` and `ϵ₂`
add small deviations to the control parameter `R`.

## Equations of motion

```math
\\begin{aligned}
\\dot{x_1} &= 10(x_2 - x_1) + C_{21}*(y_1-x_1) \\\\
\\dot{x_2} &= x_1((R+ϵ₁) - x_3) - x_2 \\\\
\\dot{x_3} &= x_1x_2 - 8/3x_3 \\\\
\\dot{y_1} &= 10(y_2 - y_1) + C_{12}(x_1-y_1) \\\\
\\dot{y_2} &= y_1((R+\\epsilon_2) - y_3) - y_2 \\\\
\\dot{y_3} &= y_1y_2 - 8/3y_3
\\end{aligned}
```

[^Martini2011]: Martini, M., Kranz, T. A., Wagner, T., & Lehnertz, K. (2011). Inferring directional interactions from transient signals with symbolic transfer entropy. Physical review E, 83(1), 011919.
"""
function lorenzdiffusive(; ui = rand(6), C₁₂::Real = 5, C₂₁::Real = 0,
        R::Real = 28.0, ϵ₁::Real = -0.02, ϵ₂::Real = 0.03)
    @warn "`lorenzdiffusive` is deprecated in CausalityTools v2. "*
    "Use `system(LorenzBidir6())` instead, which returns a "*
    "`ContinuousDynamicalSystem` that can be iterated."
    p = [C₁₂, C₂₁, R, ϵ₁, ϵ₂]
    ContinuousDynamicalSystem(eom_lorenzdiffusive, ui, p)
end

@inline @inbounds function eom_rossler_rossler_bidir(u, p, t)
    ω₁, ω₂, c_xy, c_yx, a₁, a₂, a₃, b₁, b₂, b₃ = (p...,)
    x1, x2, x3, y1, y2, y3 = (u...,)

    dx1 = -ω₁*(x2 + x3) + c_yx*(y1 - x1)
    dx2 = ω₁*x1 + a₁*x2
    dx3 = a₂ + x3*(x1 - a₃)

    dy1 = -ω₂*(y2 + y3) + c_xy*(x1 - y1)
    dy2 = ω₂*y1 + b₁*y2
    dy3 = b₂ + y3*(y1 - b₃)

    return SVector{6}(dx1, dx2, dx3, dy1, dy2, dy3)
end

"""
    rossler_rossler_bidir(; u0 = rand(6),
        ω₁ = 1.015, ω₂ = 0.985,
        c_xy = 0.1, c_yx = 0.1,
        a₁ = 0.15, a₂ = 0.2, a₃ = 10,
        b₁ = 0.15, b₂ = 0.2, b₃ = 10)

Initialise a system of two bidirectionally coupled 3D Rössler systems.
This system has been modified from [1] to allow other parameterisations,
but default parameters are as in [1].

The ``X`` and ``Y`` subsystems are mostly synchronized for
`c_xy > 0.1` or `c_yx > 0.1`.

## Equations of motion

The dynamics is generated by the following vector field

```math
\\begin{aligned}
\\dot{x_1} &= -\\omega_1(x_2 + x_3) + c_{yx}(y_1 - x_1) \\\\
\\dot{x_2} &= \\omega_1 x_1 + a_1 x_2 \\\\
\\dot{x_3} &= a_2 + x_3 (x_1 - a_3) \\\\
\\dot{y_1} &= -\\omega_2 (y_2 + y_3) + c_{xy}(x_1 - y_1) \\\\
\\dot{y_2} &= \\omega_2 y_1 + b_1 y_2 \\\\
\\dot{y_3} &= b_2 + y_3 (y_1 - b_3)
\\end{aligned}
```

## References

1. Amigó, José M., and Yoshito Hirata. "Detecting directional couplings from
    multivariate flows by the joint distance distribution." Chaos: An
    Interdisciplinary Journal of Nonlinear Science 28.7 (2018): 075302.
"""
function rossler_rossler_bidir(; u0 = rand(6),
        ω₁ = 1.015, ω₂ = 0.985,
        c_xy = 0.1, c_yx = 0.1,
        a₁ = 0.15, a₂ = 0.2, a₃ = 10,
        b₁ = 0.15, b₂ = 0.2, b₃ = 10)
    @warn "`rossler_rossler_bidir` is deprecated in CausalityTools v2. "*
    "Use `system(RosslerBidir6())` instead, which returns a "*
    "`ContinuousDynamicalSystem` that can be iterated."
    p = @LArray [ω₁, ω₂, c_xy, c_yx, a₁, a₂, a₃, b₁, b₂, b₃] (:ω₁, :ω₂, :c_xy, :c_yx, :a₁, :a₂, :a₃, :b₁, :b₂, :b₃)
    ContinuousDynamicalSystem(eom_rossler_rossler_bidir, u0, p)
end


function rossler_rossler_bidir_trajectory(npts, sample_dt; n_transient = 2000, dt = 0.2,
        u0 = rand(6), ω₁ = 1.015, ω₂ = 0.985,
        c_xy = 0.2, c_yx = 0.2,
        a₁ = 0.15, a₂ = 0.2, a₃ = 10,
        b₁ = 0.15, b₂ = 0.2, b₃ = 10)

    s = rossler_rossler_bidir(u0 = u0,
        c_xy = c_xy, c_yx = c_yx,
        ω₁ = ω₁, ω₂ = ω₂,
        a₁ = a₁, a₂ = a₂, a₃ = a₃,
        b₁ = b₁, b₂ = b₂, b₃ = b₃)
    @warn "`rossler_rossler_bidir_trajectory` is deprecated in CausalityTools v2."

    # the system is recorded at times t0:dt:T
    T = npts*dt*sample_dt
    o = trajectory(s, T, dt = dt, Ttr = n_transient*dt, alg = SimpleATsit5())[1:sample_dt:end-1, :] #alg = SimpleDiffEq.SimpleATsit5()
end

function good_rossler_rossler_bidir_trajectory(npts; sample_dt = 1,
        Da₁ = Uniform(0.12, 0.17),
        Da₂ = Uniform(0.18, 0.22),
        Da₃ = Uniform(9.0, 11.0),
        Db₁ = Uniform(0.10, 0.20),
        Db₂ = Uniform(0.18, 0.22),
        Db₃ = Uniform(9.0, 11.0),
        Dω₁ = Uniform(0.95, 0.999), #Uniform(0.97, 1.03)
        Dω₂ = Uniform(1.001, 1.05), #Uniform(0.97, 1.03)
        a₁ = nothing,
        a₂ = nothing,
        a₃ = nothing,
        b₁ = nothing,
        b₂ = nothing,
        b₃ = nothing,
        ω₁ = nothing,
        ω₂ = nothing,
        c_xy = 0.2,  c_yx = 0.2,
        Ttr = 5000, dt = 0.2,
        u0 = rand(6),
        n_maxtries = 300)

    n_tries = 0

    while n_tries <= n_maxtries
        ω₁ == nothing ? ω₁ = rand(Dω₁) : ω₁ = ω₁
        ω₂ == nothing ? ω₂ = rand(Dω₂) : ω₂ = ω₂
        a₁ == nothing ? a₁ = rand(Da₁) : a₁ = a₁
        a₂ == nothing ? a₂ = rand(Da₂) : a₂ = a₂
        a₃ == nothing ? a₃ = rand(Da₃) : a₃ = a₃
        b₁ == nothing ? b₁ = rand(Db₁) : b₁ = b₁
        b₂ == nothing ? b₂ = rand(Db₂) : b₂ = b₂
        b₃ == nothing ? b₃ = rand(Db₃) : b₃ = b₃

        pts = rossler_rossler_bidir_trajectory(npts, sample_dt, dt = dt, n_transient = Ttr,
            c_xy = c_xy,  c_yx = c_yx, ω₁ = ω₁, ω₂ = ω₂, a₁ = a₁, a₂ = a₂,a₃ = a₃,b₁ = b₁,  b₂ = b₂, b₃ = b₃)

        if all(Matrix(pts) .< 1e10) && length(unique(pts)) > npts/2
            return pts
        end
        println("no attractor found. trying with new initial condition and parameters")
        n_tries += 1
    end
end
