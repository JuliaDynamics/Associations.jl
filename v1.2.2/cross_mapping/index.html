<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Cross mapping · CausalityTools.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CausalityTools.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../surrogate/">Surrogate data</a></li><li><span class="tocitem">Distance based</span><ul><li><a class="tocitem" href="../joint_distance_distribution/">Joint distance distribution</a></li><li><a class="tocitem" href="../s_measure/">S-measure</a></li><li class="is-active"><a class="tocitem" href>Cross mapping</a><ul class="internal"><li><a class="tocitem" href="#Example:-reproducing-Sugihara-et-al.-(2012)"><span>Example: reproducing Sugihara et al. (2012)</span></a></li></ul></li><li><a class="tocitem" href="../pairwise_asymmetric_inference/">Pairwise asymmetric inference</a></li></ul></li><li><span class="tocitem">Information/entropy based</span><ul><li><a class="tocitem" href="../mutualinfo/">Mutual information</a></li><li><a class="tocitem" href="../TransferEntropy/">Transfer entropy</a></li><li><a class="tocitem" href="../predictive_asymmetry/">Predictive asymmetry</a></li><li><a class="tocitem" href="../generalized_entropy/">Generalized entropy</a></li><li><a class="tocitem" href="../info_estimators/">Estimators</a></li></ul></li><li><a class="tocitem" href="../example_systems/">Example systems</a></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="../invariant_measure/">Invariant measures and transfer operators</a></li><li><a class="tocitem" href="../dataset/">Multivariate <code>Dataset</code>s</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Distance based</a></li><li class="is-active"><a href>Cross mapping</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Cross mapping</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/CausalityTools.jl/blob/master/docs/src/cross_mapping.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Cross-mapping"><a class="docs-heading-anchor" href="#Cross-mapping">Cross mapping</a><a id="Cross-mapping-1"></a><a class="docs-heading-anchor-permalink" href="#Cross-mapping" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="CausalityTools.CrossMappings.crossmap" href="#CausalityTools.CrossMappings.crossmap"><code>CausalityTools.CrossMappings.crossmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">crossmap(x, y, d, τ; r = 0, correspondence_measure = Statistics.cor) → Float64
crossmap(x, y, d, τ, bootstrap_method::Symbol; r = 0, correspondence_measure = Statistics.cor,
    method = :segment, L = ceil(Int, (length(x)-d*τ)*0.2), nreps = 100) → Vector{Float64}</code></pre><p>Compute the cross mapping <sup class="footnote-reference"><a id="citeref-Sugihara2012" href="#footnote-Sugihara2012">[Sugihara2012]</a></sup> between <code>x</code> and <code>y</code>, which is the correspondence (computed using  <code>correspondence measure</code>) between the values <span>$y(t)$</span> and the cross-map estimated values <span>$ỹ(t) | M_x$</span>. Returns the correspondence between original and cross mapped values (the default is  <code>ρ = correspondence_measure(y(t), ỹ(t) | M_x)</code>).</p><p>Here, <span>$y(t)$</span> are the raw values of the time series <code>y</code>, and <span>$ỹ(t)$</span> are the predicted values  computed from the out-of-sample embedding <span>$M_X$</span> constructed from the time series <code>x</code> with  embedding dimension <code>d</code> and embedding lag <code>τ</code>.</p><p>The Theiler window <code>r</code> indicates how many temporal neighbors of the predictee is to be excluded  during the nearest neighbors search (the default <code>r = 0</code> excludes only the predictee itself, while  <code>r = 2</code> excludes the point itself plus its two nearest neighbors in time).</p><p>If <code>bootstrap_method</code> is specified, then <code>nreps</code> different bootstrapped estimates of  <code>correspondence_measure(y(t), ỹ(t) | M_x)</code> are returned. The following bootstrap methods are available:</p><ul><li><code>bootstrap_method = :random</code> selects training sets of length <code>L</code> consisting of randomly selected    points from the embedding <span>$M_x$</span>  (time ordering does not matter). This is method 3 from Luo    et al. (2015)<sup class="footnote-reference"><a id="citeref-Luo2015" href="#footnote-Luo2015">[Luo2015]</a></sup>, which critiqued the original Sugihara et al. methodology.</li><li><code>bootstrap_method = :segment</code> selects training sets consisting of time-contiguous segments    (each of lenght <code>L</code>) of embedding vectors in <span>$M_x$</span> (time ordering matters). This is    method 2 from Luo et al. (2015)<sup class="footnote-reference"><a id="citeref-Luo2015" href="#footnote-Luo2015">[Luo2015]</a></sup>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/CausalityTools.jl/blob/57544e86c4d87b00aaf20be562b6812f06297c31/src/CrossMappings/ccm.jl#L6-L36">source</a></section></article><h2 id="Example:-reproducing-Sugihara-et-al.-(2012)"><a class="docs-heading-anchor" href="#Example:-reproducing-Sugihara-et-al.-(2012)">Example: reproducing Sugihara et al. (2012)</a><a id="Example:-reproducing-Sugihara-et-al.-(2012)-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-reproducing-Sugihara-et-al.-(2012)" title="Permalink"></a></h2><p>Let&#39;s try to reproduce figure 3A in Sugihara et al. We start by defining the bidirectionally coupled  logistic maps they use for that example (the parameters used can be found in their supplementary material).</p><pre><code class="language-julia hljs">using CausalityTools, DynamicalSystems, Plots, StatsBase, Statistics; gr()

function eom_logistic_bidir_sugihara(dx, x, p, n)
    c_xy, c_yx, rx, ry = (p...,)
    x, y = x[1], x[2]

    dx[1] = x * (rx - rx * x - c_yx * y)
    dx[2] = y * (ry - ry * y - c_xy * x)
    return
end

function logistic_bidir_sugihara(;u₀ = rand(2), c_xy = 0.5, c_yx = 0.5, rx = 3.78, ry = 3.66)
    DiscreteDynamicalSystem(eom_logistic_bidir_sugihara, u₀, [c_xy, c_yx, rx, ry])
end

# Create a system of nonidentical logistic maps where coupling from variable x to variable y
# is stronger than vice versa.
sys = logistic_bidir_sugihara(u₀ = [0.4, 0.2], c_xy = 0.1, c_yx = 0.02, rx = 3.8, ry = 3.5)
npts = 5000
orbit = trajectory(sys, npts, Ttr = 10000)
x, y = columns(orbit);
plot(xlabel = &quot;Time step&quot;, ylabel = &quot;Value&quot;)
plot!(x[1:200], label = &quot;x&quot;)
plot!(y[1:200], label = &quot;y&quot;)</code></pre><p><img src="../ccm_sugihara_ts.svg" alt/></p><h3 id="Naive-estimation"><a class="docs-heading-anchor" href="#Naive-estimation">Naive estimation</a><a id="Naive-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Naive-estimation" title="Permalink"></a></h3><p>The most naive form sampling for the cross mapping procedure is to construct embeddings from <em>all</em>  points in the original time series. This yields a single cross map estimate. </p><pre><code class="language-julia hljs"># Embedding dimension 2, embedding lag 1
d, τ = 2, 1

# Cross map estimates from x to y, and from y to x
cm_xy, cm_yx = crossmap(x, y, d, τ), crossmap(y, x, d, τ)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.9602698466217806, 0.998791724613473)</code></pre><p>The term <em>convergent</em> cross mapping does not come into play until we compute the cross mapping for  different time series length <code>L</code>.</p><p>If <span>$cor(y(t), ỹ(t) | M_x)$</span> converges with increasing time  series length<sup class="footnote-reference"><a id="citeref-Sugihara2012" href="#footnote-Sugihara2012">[Sugihara2012]</a></sup>, or library size <code>L</code> in the case of bootstrapping (see below), then  <span>$M_x$</span> contains information about <span>$y$</span>. In the context of causal inference, this means that <code>x</code> causally influences <code>y</code>, and there is a directional dynamical coupling from <code>x</code> to <code>y</code>.  Conversely, if <span>$cor(x(t), x̃(t) | M_y)$</span>  converges with increasing time series length or <code>L</code>, then that is interpreted as dynamical coupling from <code>y</code> to <code>x</code>.</p><p>Let&#39;s see if either is true for these example time series. We&#39;ll increase <code>L</code> by simply subsampling the time  series from index <code>1</code> to <code>L</code> for increasing <code>L</code>.</p><pre><code class="language-julia hljs"># Select some time series lengths
Ls = [10:10:100; 120:20:300; 350:50:1000]

cs_xy_increasing_segments = [crossmap(x[1:L], y[1:L], d, τ) for L in Ls]
cs_yx_increasing_segments = [crossmap(y[1:L], x[1:L], d, τ) for L in Ls]

p_naive_segments = plot(legend = :bottomright, ylabel = &quot;Correlation (ρ)&quot;, xlabel = &quot;Library size (L)&quot;)
plot!(Ls, cs_xy_increasing_segments, c = :black, lw = 2, ls = :dot, label = &quot;cor(Y(t), Ỹ(t) | Mx), segments from start to L&quot;)
plot!(Ls, cs_yx_increasing_segments, c = :green, lw = 2, ls = :dash, label = &quot;cor(X(t), X̃(t) | My), segments from start to L&quot;)
ylims!((-0.05, 1.05))</code></pre><p><img src="../ccm_naive.svg" alt/></p><p>As in the original CCM paper, we observe that the correlation between observed and  cross-map estimated values is stronger and converges faster when using <span>$M_y$</span> to  estimate <span>$x̃(t)$</span> (green), than when using <span>$M_x$</span> to estimate <span>$ỹ(t)$</span> (black).  Why? In this example, we set <code>c_xy = 0.1</code> and <code>c_yx = 0.02</code>. Therefore, <em>&quot;... the much stronger effect of species X on Y implies faster convergence for predicting X than for Y&quot;</em> (Sugihara et al., 2012)<sup class="footnote-reference"><a id="citeref-Sugihara2012" href="#footnote-Sugihara2012">[Sugihara2012]</a></sup>.</p><h3 id="Bootstrapping"><a class="docs-heading-anchor" href="#Bootstrapping">Bootstrapping</a><a id="Bootstrapping-1"></a><a class="docs-heading-anchor-permalink" href="#Bootstrapping" title="Permalink"></a></h3><p>Computing a single estimate for the cross mapping is essentially the same as computing a single estimate for the mean of a sample. To more robustly estimate the cross map statistic, we can use bootstrapping.  To do so, we simply employ the five-argument version of the <code>crossmap</code> function, where the fifth argument is  a symbol indicating the type of bootstrapping.</p><p>Using the same library sizes as before, we repeat the cross mapping procedure, but using bootstrapping. For each <code>L</code>, we obtain <code>nreps = 100</code> different estimates of <code>ρ</code> and plot the 95 percentile confidence intervals.</p><pre><code class="language-julia hljs">Ls = [10:10:100; 120:20:300; 350:50:1000]
nreps = 200
cs_xy = [crossmap(x, y, d, τ, :random, L = L, nreps = nreps) for L in Ls]
cs_xy_seg = [crossmap(x, y, d, τ, :segment, L = L, nreps = nreps) for L in Ls]
cs_yx = [crossmap(y, x, d, τ, L = L, :random, nreps = nreps) for L in Ls]
cs_yx_seg = [crossmap(y, x, d, τ, :segment, L = L, nreps = nreps) for L in Ls]

cs_xy_lower = median.(cs_xy) .- [quantile(cs_xy[i], 0.025) for i = 1:length(Ls)]
cs_xy_upper = [quantile(cs_xy[i], 0.975) for i = 1:length(Ls)] .- median.(cs_xy)
cs_yx_lower = median.(cs_yx) .- [quantile(cs_yx[i], 0.025) for i = 1:length(Ls)]
cs_yx_upper = [quantile(cs_yx[i], 0.975) for i = 1:length(Ls)] .- median.(cs_yx)

cs_xy_seg_lower = median.(cs_xy_seg) .- [quantile(cs_xy_seg[i], 0.025) for i = 1:length(Ls)]
cs_xy_seg_upper = [quantile(cs_xy_seg[i], 0.975) for i = 1:length(Ls)] .- median.(cs_xy_seg)

cs_yx_seg_lower = median.(cs_yx_seg) .- [quantile(cs_yx_seg[i], 0.025) for i = 1:length(Ls)]
cs_yx_seg_upper = [quantile(cs_yx_seg[i], 0.975) for i = 1:length(Ls)] .- median.(cs_yx_seg)

p_random = plot(legend = :bottomright, ylabel = &quot;Correlation (ρ)&quot;, xlabel = &quot;Library size (L)&quot;)
plot!(Ls, median.(cs_xy), ribbon = (cs_xy_lower, cs_xy_upper),
    label = &quot;cor(Y(t), Ỹ(t)|Mx), libraries: random points&quot;, c = :black)
    plot!(Ls, median.(cs_xy_seg), ribbon = (cs_xy_seg_lower, cs_xy_seg_upper),
    label = &quot;cor(Y(t), Ỹ(t)|Mx), libraries: random segments&quot;, c = :black, ls = :dash)
ylims!((-0.05, 1.05))

plot!(Ls, median.(cs_yx), ribbon = (cs_yx_lower, cs_yx_upper),
    label = &quot;cor(X(t), X̃(t)|My), libraries: random points&quot;, c = :green)
plot!(Ls, median.(cs_yx_seg), ribbon = (cs_yx_seg_lower, cs_yx_seg_upper),
    label = &quot;cor(X(t), X̃(t)|My), libraries: random segments&quot;, c = :green, ls = :dot)
ylims!((-0.05, 1.05))

#plot(p_random, p_segments, layout = grid(1, 2), size = (800, 350))</code></pre><p><img src="../ccm_bootstrap.svg" alt/></p><p>When using bootstrapping, we get the same results as when contiguous segments of the  original time series: using <span>$M_y$</span> to estimate <span>$x̃(t)$</span> converges faster than in the opposite direction due to the stronger influence from  <code>x</code> to <code>y</code> than vice versa. </p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Sugihara2012"><a class="tag is-link" href="#citeref-Sugihara2012">Sugihara2012</a>Sugihara, George, et al. &quot;Detecting causality in complex ecosystems.&quot; Science (2012): 1227079.<a href="http://science.sciencemag.org/content/early/2012/09/19/science.1227079">http://science.sciencemag.org/content/early/2012/09/19/science.1227079</a></li><li class="footnote" id="footnote-Luo2015"><a class="tag is-link" href="#citeref-Luo2015">Luo2015</a>&quot;Questionable causality: Cosmic rays to temperature.&quot; Proceedings of the National Academy of Sciences Aug 2015, 112 (34) E4638-E4639; DOI: 10.1073/pnas.1510571112 Ming Luo, Holger Kantz, Ngar-Cheung Lau, Wenwen Huang, Yu Zhou</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../s_measure/">« S-measure</a><a class="docs-footer-nextpage" href="../pairwise_asymmetric_inference/">Pairwise asymmetric inference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Saturday 21 May 2022 19:43">Saturday 21 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
