<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Transfer entropy · CausalityTools.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CausalityTools.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../surrogate/">Surrogate data</a></li><li><span class="tocitem">Distance based</span><ul><li><a class="tocitem" href="../joint_distance_distribution/">Joint distance distribution</a></li><li><a class="tocitem" href="../s_measure/">S-measure</a></li><li><a class="tocitem" href="../cross_mapping/">Cross mapping</a></li><li><a class="tocitem" href="../pairwise_asymmetric_inference/">Pairwise asymmetric inference</a></li></ul></li><li><span class="tocitem">Information/entropy based</span><ul><li><a class="tocitem" href="../mutualinfo/">Mutual information</a></li><li class="is-active"><a class="tocitem" href>Transfer entropy</a><ul class="internal"><li><a class="tocitem" href="#Traditional"><span>Traditional</span></a></li><li><a class="tocitem" href="#Automated-variable-selection"><span>Automated variable selection</span></a></li><li><a class="tocitem" href="#Example:-Reproducing-Schreiber-(2000)"><span>Example: Reproducing Schreiber (2000)</span></a></li></ul></li><li><a class="tocitem" href="../predictive_asymmetry/">Predictive asymmetry</a></li><li><a class="tocitem" href="../generalized_entropy/">Generalized entropy</a></li><li><a class="tocitem" href="../info_estimators/">Estimators</a></li></ul></li><li><a class="tocitem" href="../example_systems/">Example systems</a></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="../invariant_measure/">Invariant measures and transfer operators</a></li><li><a class="tocitem" href="../dataset/">Multivariate <code>Dataset</code>s</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Information/entropy based</a></li><li class="is-active"><a href>Transfer entropy</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Transfer entropy</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/CausalityTools.jl/blob/master/docs/src/TransferEntropy.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="[Transfer-entropy](@ref-transferentropy)"><a class="docs-heading-anchor" href="#[Transfer-entropy](@ref-transferentropy)"><a href="@ref transferentropy">Transfer entropy</a></a><a id="[Transfer-entropy](@ref-transferentropy)-1"></a><a class="docs-heading-anchor-permalink" href="#[Transfer-entropy](@ref-transferentropy)" title="Permalink"></a></h1><h2 id="Traditional"><a class="docs-heading-anchor" href="#Traditional">Traditional</a><a id="Traditional-1"></a><a class="docs-heading-anchor-permalink" href="#Traditional" title="Permalink"></a></h2><p>The following <code>transferentropy</code> function computes transfer entropy &quot;manually&quot;, that is, in addition to specifying an estimator, you have to specify embedding parameters.</p><article class="docstring"><header><a class="docstring-binding" id="TransferEntropy.transferentropy" href="#TransferEntropy.transferentropy"><code>TransferEntropy.transferentropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transferentropy(s, t, [c,] est; base = 2, q = 1, 
    τT = -1, τS = -1, η𝒯 = 1, dT = 1, dS = 1, d𝒯 = 1, [τC = -1, dC = 1]
)</code></pre><p>Estimate transfer entropy<sup class="footnote-reference"><a id="citeref-Schreiber2000" href="#footnote-Schreiber2000">[Schreiber2000]</a></sup> from source <code>s</code> to target <code>t</code>, <span>$TE^{q}(s \to t)$</span>, using the  provided entropy/probability estimator <code>est</code> with logarithms to the given <code>base</code>. Optionally, condition  on <code>c</code> and estimate the conditional transfer entropy <span>$TE^{q}(s \to t | c)$</span>. The input series <code>s</code>, <code>t</code>, and <code>c</code> must be equal-length real-valued vectors.</p><p>Compute either Shannon transfer entropy (<code>q = 1</code>, which is the default) or the order-<code>q</code>  Rényi transfer entropy<sup class="footnote-reference"><a id="citeref-Jizba2012" href="#footnote-Jizba2012">[Jizba2012]</a></sup> by setting <code>q</code> different from 1.</p><p>All possible estimators that can be used are described in the online documentation.</p><p><strong>Keyword Arguments</strong></p><p>Keyword arguments tune the embedding that will be done to each of the timeseries (with more details following below). In short, the embedding lags <code>τT</code>, <code>τS</code>, <code>τC</code> must be zero or negative, the  prediction lag <code>η𝒯</code> must be positive, and the embedding dimensions <code>dT</code>, <code>dS</code>, <code>dC</code>, <code>d𝒯</code>  must be greater than or equal to 1. Thus, the convention is to use negative lags to  indicate embedding delays for past state vectors (for the <span>$T$</span>, <span>$S$</span> and <span>$C$</span> marginals,  detailed below), and positive lags to indicate embedding delays for future state vectors  (for the <span>$\mathcal T$</span> marginal, also detailed below). </p><p>The default behaviour is to use scalar timeseries for past state vectors (in that case, the <code>τT</code>, <code>τS</code> or <code>τC</code> does not affect the analysis).</p><p><strong>Description</strong></p><p><strong>Transfer entropy on scalar time series</strong></p><p>Transfer entropy<sup class="footnote-reference"><a id="citeref-Schreiber2000" href="#footnote-Schreiber2000">[Schreiber2000]</a></sup> between two simultaneously measured scalar time series <span>$s(n)$</span> and <span>$t(n)$</span>,   <span>$s(n) = \{ s_1, s_2, \ldots, s_N \}$</span> and <span>$t(n) = \{ t_1, t_2, \ldots, t_N \}$</span>, is is defined as </p><p class="math-container">\[TE(s \to t) = \sum_i p(s_i, t_i, t_{i+\eta}) \log \left( \dfrac{p(t_{i+\eta} | t_i, s_i)}{p(t_{i+\eta} | t_i)} \right)\]</p><p><strong>Transfer entropy on generalized embeddings</strong></p><p>By defining the vector-valued time series, it is possible to include more than one  historical/future value for each marginal (see &#39;Uniform vs. non-uniform embeddings&#39; below for embedding details):</p><ul><li><span>$\mathcal{T}^{(d_{\mathcal T}, \eta_{\mathcal T})} = \{t_i^{(d_{\mathcal T}, \eta_{\mathcal T})} \}_{i=1}^{N}$</span>, </li><li><span>$T^{(d_T, \tau_T)} = \{t_i^{(d_T, \tau_T)} \}_{i=1}^{N}$</span>, </li><li><span>$S^{(d_S, \tau_S)} = \{s_i^{(d_T, \tau_T)} \}_{i=1}^{N}$</span>,  and </li><li><span>$C^{(d_C, \tau_C)} = \{s_i^{(d_C, \tau_C)} \}_{i=1}^{N}$</span>.</li></ul><p>The non-conditioned generalized and conditioned generalized forms of the transfer entropy are then</p><p class="math-container">\[TE(s \to t) = \sum_i p(S,T, \mathcal{T}) \log \left( \dfrac{p(\mathcal{T} | T, S)}{p(\mathcal{T} | T)} \right)\]</p><p class="math-container">\[TE(s \to t | c) = \sum_i p(S,T, \mathcal{T}, C) \log \left( \dfrac{p(\mathcal{T} | T, S, C)}{p(\mathcal{T} | T, C)} \right)\]</p><p><strong>Uniform vs. non-uniform embeddings</strong></p><p>The <code>N</code> state vectors for each marginal are either </p><ul><li>uniform, of the form <span>$x_{i}^{(d, \omega)} = (x_i, x_{i+\omega}, x_{i+2\omega}, \ldots x_{i+(d - 1)\omega})$</span>,    with equally spaced state vector entries. <em>Note: When constructing marginals for <span>$T$</span>, <span>$S$</span> and <span>$C$</span>,    we need <span>$\omega \leq 0$</span> to get present/past values, while <span>$\omega &gt; 0$</span> is necessary to get future states    when constructing <span>$\mathcal{T}$</span>.</em></li><li>non-uniform, of the form <span>$x_{i}^{(d, \omega)} = (x_i, x_{i+\omega_1}, x_{i+\omega_2}, \ldots x_{i+\omega_{d}})$</span>,   with non-equally spaced state vector entries <span>$\omega_1, \omega_2, \ldots, \omega_{d}$</span>,   which can be freely chosen. <em>Note: When constructing marginals for <span>$T$</span>, <span>$S$</span> and <span>$C$</span>,    we need <span>$\omega_i \leq 0$</span> for all <span>$\omega_i$</span> to get present/past values, while <span>$\omega_i &gt; 0$</span> for all <span>$\omega_i$</span>    is necessary to get future states when constructing <span>$\mathcal{T}$</span>.</em></li></ul><p>In practice, the <code>dT</code>-dimensional, <code>dS</code>-dimensional and <code>dC</code>-dimensional state vectors  comprising <span>$T$</span>, <span>$S$</span> and <span>$C$</span> are constructed with embedding lags <code>τT</code>,  <code>τS</code>, and <code>τC</code>, respectively. The <code>d𝒯</code>-dimensional future states <span>$\mathcal{T}^{(d_{\mathcal T}, \eta_{\mathcal T})}$</span> are constructed with prediction lag <code>η𝒯</code> (i.e. predictions go from present/past states to  future states spanning a maximum of <code>d𝒯*η𝒯</code> time steps). <em>Note: in Schreiber&#39;s paper, only the historical states are defined as  potentially higher-dimensional, while the future states are always scalar.</em></p><p><strong>Estimation</strong></p><p>Transfer entropy is here estimated by rewriting the above expressions as a sum of marginal  entropies, and extending the definitions above to use Rényi generalized entropies of order  <code>q</code> as</p><p class="math-container">\[TE^{q}(s \to t) = H^{q}(\mathcal T, T) + H^{q}(T, S) - H^{q}(T) - H^{q}(\mathcal T, T, S),\]</p><p class="math-container">\[TE^{q}(s \to t | c) = H^{q}(\mathcal T, T, C) + H^{q}(T, S, C) - H^{q}(T, C) - H^{q}(\mathcal T, T, S, C),\]</p><p>where <span>$H^{q}(\cdot)$</span> is the generalized Rényi entropy of order <span>$q$</span>. This is equivalent to the Rényi transfer entropy implementation in Jizba et al. (2012)<sup class="footnote-reference"><a id="citeref-Jizba2012" href="#footnote-Jizba2012">[Jizba2012]</a></sup>.</p><p><strong>Examples</strong></p><p>Default estimation (scalar marginals): </p><pre><code class="language-julia hljs"># Symbolic estimator, motifs of length 4, uniform delay vectors with lag 1
est = SymbolicPermutation(m = 4, τ = 1) 

x, y = rand(100), rand(100)
transferentropy(x, y, est)</code></pre><p>Increasing the dimensionality of the <span>$T$</span> marginal (present/past states of the target  variable):</p><pre><code class="language-julia hljs"># Binning-based estimator
est = VisitationFrequency(RectangularBinning(4)) 
x, y = rand(100), rand(100)

# Uniform delay vectors when `τT` is an integer (see explanation above)
# Here t_{i}^{(dT, τT)} = (t_i, t_{i+τ}, t_{i+2τ}, \ldots t_{i+(dT-1)τ})
# = (t_i, t_{i-2}, t_{i-4}, \ldots t_{i-6τ}), so we need zero/negative values for `τT`.
transferentropy(x, y, est, dT = 4, τT = -2)

# Non-uniform delay vectors when `τT` is a vector of integers
# Here t_{i}^{(dT, τT)} = (t_i, t_{i+τ_{1}}, t_{i+τ_{2}}, \ldots t_{i+τ_{dT}})
# = (t_i, t_{i-7}, t_{i-25}), so we need zero/negative values for `τT`.
transferentropy(x, y, est, dT = 3, τT = [0, -7, -25])</code></pre><p>Logarithm bases and the order of the Rényi entropy can also be tuned:</p><pre><code class="language-julia hljs">x, y = rand(100), rand(100)
est = NaiveKernel(0.3)
transferentropy(x, y, est, base = MathConstants.e, q = 2) # TE in nats, order-2 Rényi entropy</code></pre></div></section></article><h2 id="Automated-variable-selection"><a class="docs-heading-anchor" href="#Automated-variable-selection">Automated variable selection</a><a id="Automated-variable-selection-1"></a><a class="docs-heading-anchor-permalink" href="#Automated-variable-selection" title="Permalink"></a></h2><p>The <code>bbnue</code> function optimizes embedding parameters using an iterative procedure for  variable selection, and performs null hypothesis testing as part of that procedure.</p><article class="docstring"><header><a class="docstring-binding" id="TransferEntropy.bbnue" href="#TransferEntropy.bbnue"><code>TransferEntropy.bbnue</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bbnue(source, target, [cond], est; 
    η = 1, include_instantaneous = true, 
    method_delay = &quot;ac_min&quot;, maxlag::Union{Int, Float64} = 0.05,
    surr::Surrogate = RandomShuffle(), nsurr = 100, α = 0.05)
    ) → te, js, τs, idxs_source, idxs_target, idxs_cond</code></pre><p>Estimate transfer entropy (TE) from <code>source</code> to <code>target</code> (conditioned on <code>cond</code> if given) for prediction lag <code>η</code>, using the bootstrap-based non-uniform embedding (BBNUE)  method from Montalta et al. (2004) <sup class="footnote-reference"><a id="citeref-Montalto2014" href="#footnote-Montalto2014">[Montalto2014]</a></sup>.</p><p><strong>Implementation details</strong></p><p>The BBNUE method uses a bootstrap-based criterion to identify the most relevant and  minimally redundant variables from the the past of <code>target</code>, present/past of <code>source</code>,  and (if given) the present/past of <code>cond</code>, that contribute most to <code>target</code>&#39;s future. </p><p>This implementation uses a conditional entropy minimization criterion for selecting variables, which is what Montalto et al. (2014)<sup class="footnote-reference"><a id="citeref-Montalto2014" href="#footnote-Montalto2014">[Montalto2014]</a></sup> uses for their bin-estimator. Here, any  estimator can be used, but variables will be selected using conditional entropy minimization  regardless of the choice of estimator.</p><p>Montalto et al.&#39;s bin-estimator corresponds to using the <code>VisitationFrequency</code> estimator with bins  whose sides are equal-length, e.g. <code>VisitationFrequency(RectangularBinning(0.5))</code>.  In this implementation, any rectangular binning can be used.</p><p><strong>Input data</strong></p><p>Multivariate <code>source</code>, <code>target</code> and <code>cond</code> (if given) can be given as univariate  <code>AbstractVector</code>s or as multivariate <code>Dataset</code>s or <code>Vector{AbstractVector}</code>. </p><p>For example, if you want to compute  the BBNUE-transfer entropy from a univariate source to a univariate target,  potentially conditioned on many different variables, you can do the following:</p><pre><code class="language-julia hljs">n = 1000
# Source and target variables
s, t = rand(n), rand(n)

# Variables that might potentially influence `t` along with `s`
c1, c2, c3 = rand(n), rand(n), rand(n)

est = NaiveKernel(0.3)
bbnue(s, t, Dataset([c1, c2, c3]), est)</code></pre><p><strong>Variable selection and significance testing</strong></p><p>In this implementation, the maximum lag for each embedding variable is determined using <code>estimate_delay</code>  from <code>DelayEmbeddings</code>. The keywords <code>method_delay</code> (the default is <code>&quot;ac_min&quot;</code>) controls the method  for estimating the delay, and <code>maxlag</code> is the maximum allowed delay (if <code>maxlag ∈ [0, 1]</code> is a fraction,  then the maximum lag is that fraction of the input time series length, and if <code>maxlag</code> is an integer,  then the maximum lag is <code>maxlag</code>).</p><p>If <code>instantaneous</code> is <code>true</code>, then instantaneous interactions are also considered, i.e. effects like  <code>source(t) → target(t)</code> are allowed. <code>η</code> is the forward prediction lag. </p><p>Significance testing is performed using a permutation test. At each iteration of the  variable selection routine, we first compute the transfer entropy using the new candidate  <span>$c_k$</span>. Then, the computation is repeated <code>nsurr</code> times, at each iteration replacing <span>$c_k$</span>  with a surrogate of type <code>surr</code>. If transfer entropy using the original <span>$c_k$</span> exceeds the  the <code>1 - α</code>-quantile of that of the surrogate ensemble, then <span>$c_k$</span> is deemed significant  to the future of <code>target</code> and is included in the set of selected variables.</p><p>If no relevant variables pass the permutation test, then TE is not well-defined, and a value of <code>0.0</code> is returned.</p><p><strong>Returns</strong></p><p>A 6-tuple is returned, consisting of:</p><ul><li><code>te</code>: The computed transfer entropy value. </li><li><code>js</code>: The indices of the selected variables. <code>js[i]</code> is the <code>i</code>-th entry in the array <code>[idxs_source..., idxs_target..., idxs_cond...,]</code>.</li><li><code>τs</code>: The embedding lags of the selected variables. <code>τs[i]</code> corresponds to <code>js[i]</code>.</li><li><code>idxs_source</code>: The indices of the source variables.</li><li><code>idxs_target</code>: The indices of the target variables.</li><li><code>idxs_cond</code>: The indices of the conditional variables (empty if <code>cond</code> is not given).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using CausalityTools, DynamicalSystems
sys = ExampleSystems.logistic2_unidir(c_xy = 0.8, r₁ = 3.78, r₂ = 3.92)
orbit = trajectory(sys, 10000, Ttr = 10000)
x, y = columns(orbit)

# Use a coarse-grained rectangular binning with subdivisions in each dimension,
# to keep computation costs low and to ensure the probability distributions 
# over the bins don&#39;t approach the uniform distribution (need enough points 
# to fill bins).
est = NaiveKernel(0.3)
te_xy = bbnue(x, y, est, surr = RandomShuffle(), nsurr = 100, include_instantaneous = true)
te_yx = bbnue(y, x, est, surr = RandomShuffle(), nsurr = 100, include_instantaneous = true)

te_xy, te_yx</code></pre></div></section></article><h2 id="Example:-Reproducing-Schreiber-(2000)"><a class="docs-heading-anchor" href="#Example:-Reproducing-Schreiber-(2000)">Example: Reproducing Schreiber (2000)</a><a id="Example:-Reproducing-Schreiber-(2000)-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Reproducing-Schreiber-(2000)" title="Permalink"></a></h2><p>Let&#39;s try to reproduce the results from Schreiber&#39;s original paper<sup class="footnote-reference"><a id="citeref-Schreiber2000" href="#footnote-Schreiber2000">[Schreiber2000]</a></sup> on transfer entropy. We&#39;ll use a  visitation frequency estimator, which computes entropies by counting visits of the system&#39;s orbit to discrete portions  of its reconstructed state space.</p><pre><code class="language-julia hljs">using DynamicalSystems, CausalityTools, Plots, Random, StatsBase

Random.seed!(12234)

function ulam_system(dx, x, p, t)
    f(x) = 2 - x^2
    ε = p[1]
    dx[1] = f(ε*x[length(dx)] + (1-ε)*x[1])
    for i in 2:length(dx)
        dx[i] = f(ε*x[i-1] + (1-ε)*x[i])
    end
end

ds = DiscreteDynamicalSystem(ulam_system, rand(100) .- 0.5, [0.04])
trajectory(ds, 1000; Ttr = 1000)

εs = 0.02:0.02:1.0
te_x1x2 = zeros(length(εs)); te_x2x1 = zeros(length(εs))

for (i, ε) in enumerate(εs)
    set_parameter!(ds, 1, ε)
    tr = trajectory(ds, 2000; Ttr = 5000)
    X1 = tr[:, 1]; X2 = tr[:, 2]
    @assert !any(isnan, X1)
    @assert !any(isnan, X2)
    binning = RectangularBinning(0.2) # guess an appropriate bin width of 0.2
    te_x1x2[i] = transferentropy(X1, X2, VisitationFrequency(binning), base = 2)
    te_x2x1[i] = transferentropy(X2, X1, VisitationFrequency(binning), base = 2)
end

plot()
plot(εs, te_x1x2, label = &quot;X1 to X2&quot;, c = :black, lw = 1.5)
plot!(εs, te_x2x1, label = &quot;X2 to X1&quot;, c = :red)
xlabel!(&quot;epsilon&quot;)
ylabel!(&quot;Transfer entropy (bits)&quot;)</code></pre><p><img src="../ulam-te.svg" alt/></p><p>As expected, transfer entropy from <code>X1</code> to <code>X2</code> is higher than from <code>X2</code> to <code>X1</code> across parameter values for <code>ε</code>. But, by our definition of the <code>ulam</code> system, dynamical coupling only occurs from <code>X1</code> to <code>X2</code>. The results, however,  show nonzero transfer entropy in both directions. What does this mean? </p><p>Computing transfer entropy from finite time series introduces bias, and so does any particular choice of entropy estimator used to calculate it. To determine whether a transfer entropy estimate should be trusted, we can employ <em>surrogate testing</em>. We&#39;ll generate surrogate using <a href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl">TimeseriesSurrogates.jl</a>.</p><p>In the example below, we continue with the same time series generated above. However, at each value of <code>ε</code>, we also compute transfer entropy for <code>nsurr = 50</code> different randomly shuffled (permuted) versions of the source process.  If the original transfer entropy exceeds that of some percentile the transfer entropy estimates of the surrogate ensemble, we will take that as &quot;significant&quot; transfer entropy.</p><pre><code class="language-julia hljs">nsurr = 50
te_x1x2 = zeros(length(εs)); te_x2x1 = zeros(length(εs))
te_x1x2_surr = zeros(length(εs), nsurr); te_x2x1_surr = zeros(length(εs), nsurr)

for (i, ε) in enumerate(εs)
    set_parameter!(ds, 1, ε)
    tr = trajectory(ds, 1000; Ttr = 5000)
    X1 = tr[:, 1]; X2 = tr[:, 2]
    @assert !any(isnan, X1)
    @assert !any(isnan, X2)
    binning = RectangularBinning(0.2) # guess an appropriate bin width of 0.2
    est = VisitationFrequency(binning)
    te_x1x2[i] = transferentropy(X1, X2, est, base = 2)
    te_x2x1[i] = transferentropy(X2, X1, est, base = 2)
    s1 = surrogenerator(X1, RandomShuffle()); s2 = surrogenerator(X2, RandomShuffle())

    for j = 1:nsurr
        te_x1x2_surr[i, j] =  transferentropy(s1(), X2, est, base = 2)
        te_x2x1_surr[i, j] =  transferentropy(s2(), X1, est, base = 2)
    end
end

# Compute 95th percentiles of the surrogates for each ε
qs_x1x2 = [quantile(te_x1x2_surr[i, :], 0.95) for i = 1:length(εs)]
qs_x2x1 = [quantile(te_x2x1_surr[i, :], 0.95) for i = 1:length(εs)]

plot(xlabel = &quot;epsilon&quot;, ylabel = &quot;Transfer entropy (bits)&quot;, legend = :topleft)
plot!(εs, te_x1x2, label = &quot;X1 to X2&quot;, c = :black, lw = 1.5)
plot!(εs, qs_x1x2, label = &quot;&quot;, c = :black, ls = :dot, lw = 1.5)
plot!(εs, te_x2x1, label = &quot;X2 to X1&quot;, c = :red)
plot!(εs, qs_x2x1, label = &quot;&quot;, c = :red, ls = :dot)</code></pre><p><img src="../ulam-te-surr.svg" alt/></p><p>The plot above shows the original transfer entropies (solid lines) and the 95th percentile transfer entropies of the surrogate ensembles (dotted lines). As expected, using the surrogate test, the transfer entropies from <code>X1</code> to <code>X2</code> are mostly significant (solid black line is <em>above</em> dashed black line). The transfer entropies from <code>X2</code> to <code>X1</code>, on the other hand, are mostly not significant (red solid line is <em>below</em> red dotted line).</p><p><sup class="footnote-reference"><a id="citeref-Schreiber2000" href="#footnote-Schreiber2000">[Schreiber2000]</a></sup>(Schreiber, Thomas. &quot;Measuring information transfer.&quot; Physical review letters 85.2 (2000): 461.)</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Schreiber2000"><a class="tag is-link" href="#citeref-Schreiber2000">Schreiber2000</a>Schreiber, T. (2000). Measuring information transfer. Physical review letters, 85(2), 461.</li><li class="footnote" id="footnote-Jizba2012"><a class="tag is-link" href="#citeref-Jizba2012">Jizba2012</a>Jizba, P., Kleinert, H., &amp; Shefaat, M. (2012). Rényi’s information transfer between financial time series. Physica A: Statistical Mechanics and its Applications, 391(10), 2971-2989.</li><li class="footnote" id="footnote-Montalto2014"><a class="tag is-link" href="#citeref-Montalto2014">Montalto2014</a>Montalto, A.; Faes, L.; Marinazzo, D. MuTE: A MATLAB toolbox to compare established and novel estimators of the multivariate transfer entropy. PLoS ONE 2014, 9, e109462.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../mutualinfo/">« Mutual information</a><a class="docs-footer-nextpage" href="../predictive_asymmetry/">Predictive asymmetry »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Monday 31 January 2022 11:18">Monday 31 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
